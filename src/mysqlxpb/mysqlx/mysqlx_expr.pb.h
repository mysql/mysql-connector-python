/*
 * MySQL Connector/Python - MySQL driver written in Python.
 * Copyright (c) 2017, Oracle and/or its affiliates. All rights reserved.
 *
 * MySQL Connector/Python is licensed under the terms of the GPLv2
 * <http://www.gnu.org/licenses/old-licenses/gpl-2.0.html>, like most
 * MySQL Connectors. There are special exceptions to the terms and
 * conditions of the GPLv2 as it is applied to this software, see the
 * FOSS License Exception
 * <http://www.mysql.com/about/legal/licensing/foss-exception.html>.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
 */

// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mysqlx_expr.proto

#ifndef PROTOBUF_mysqlx_5fexpr_2eproto__INCLUDED
#define PROTOBUF_mysqlx_5fexpr_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "mysqlx_datatypes.pb.h"
// @@protoc_insertion_point(includes)

namespace Mysqlx {
namespace Expr {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_mysqlx_5fexpr_2eproto();
void protobuf_AssignDesc_mysqlx_5fexpr_2eproto();
void protobuf_ShutdownFile_mysqlx_5fexpr_2eproto();

class Expr;
class Identifier;
class DocumentPathItem;
class ColumnIdentifier;
class FunctionCall;
class Operator;
class Object;
class Object_ObjectField;
class Array;

enum Expr_Type {
  Expr_Type_IDENT = 1,
  Expr_Type_LITERAL = 2,
  Expr_Type_VARIABLE = 3,
  Expr_Type_FUNC_CALL = 4,
  Expr_Type_OPERATOR = 5,
  Expr_Type_PLACEHOLDER = 6,
  Expr_Type_OBJECT = 7,
  Expr_Type_ARRAY = 8
};
bool Expr_Type_IsValid(int value);
const Expr_Type Expr_Type_Type_MIN = Expr_Type_IDENT;
const Expr_Type Expr_Type_Type_MAX = Expr_Type_ARRAY;
const int Expr_Type_Type_ARRAYSIZE = Expr_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Expr_Type_descriptor();
inline const ::std::string& Expr_Type_Name(Expr_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Expr_Type_descriptor(), value);
}
inline bool Expr_Type_Parse(
    const ::std::string& name, Expr_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Expr_Type>(
    Expr_Type_descriptor(), name, value);
}
enum DocumentPathItem_Type {
  DocumentPathItem_Type_MEMBER = 1,
  DocumentPathItem_Type_MEMBER_ASTERISK = 2,
  DocumentPathItem_Type_ARRAY_INDEX = 3,
  DocumentPathItem_Type_ARRAY_INDEX_ASTERISK = 4,
  DocumentPathItem_Type_DOUBLE_ASTERISK = 5
};
bool DocumentPathItem_Type_IsValid(int value);
const DocumentPathItem_Type DocumentPathItem_Type_Type_MIN = DocumentPathItem_Type_MEMBER;
const DocumentPathItem_Type DocumentPathItem_Type_Type_MAX = DocumentPathItem_Type_DOUBLE_ASTERISK;
const int DocumentPathItem_Type_Type_ARRAYSIZE = DocumentPathItem_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* DocumentPathItem_Type_descriptor();
inline const ::std::string& DocumentPathItem_Type_Name(DocumentPathItem_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    DocumentPathItem_Type_descriptor(), value);
}
inline bool DocumentPathItem_Type_Parse(
    const ::std::string& name, DocumentPathItem_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DocumentPathItem_Type>(
    DocumentPathItem_Type_descriptor(), name, value);
}
// ===================================================================

class Expr : public ::google::protobuf::Message {
 public:
  Expr();
  virtual ~Expr();

  Expr(const Expr& from);

  inline Expr& operator=(const Expr& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Expr& default_instance();

  void Swap(Expr* other);

  // implements Message ----------------------------------------------

  Expr* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Expr& from);
  void MergeFrom(const Expr& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Expr_Type Type;
  static const Type IDENT = Expr_Type_IDENT;
  static const Type LITERAL = Expr_Type_LITERAL;
  static const Type VARIABLE = Expr_Type_VARIABLE;
  static const Type FUNC_CALL = Expr_Type_FUNC_CALL;
  static const Type OPERATOR = Expr_Type_OPERATOR;
  static const Type PLACEHOLDER = Expr_Type_PLACEHOLDER;
  static const Type OBJECT = Expr_Type_OBJECT;
  static const Type ARRAY = Expr_Type_ARRAY;
  static inline bool Type_IsValid(int value) {
    return Expr_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Expr_Type_Type_MIN;
  static const Type Type_MAX =
    Expr_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Expr_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Expr_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Expr_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Expr_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .Mysqlx.Expr.Expr.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::Mysqlx::Expr::Expr_Type type() const;
  inline void set_type(::Mysqlx::Expr::Expr_Type value);

  // optional .Mysqlx.Expr.ColumnIdentifier identifier = 2;
  inline bool has_identifier() const;
  inline void clear_identifier();
  static const int kIdentifierFieldNumber = 2;
  inline const ::Mysqlx::Expr::ColumnIdentifier& identifier() const;
  inline ::Mysqlx::Expr::ColumnIdentifier* mutable_identifier();
  inline ::Mysqlx::Expr::ColumnIdentifier* release_identifier();
  inline void set_allocated_identifier(::Mysqlx::Expr::ColumnIdentifier* identifier);

  // optional string variable = 3;
  inline bool has_variable() const;
  inline void clear_variable();
  static const int kVariableFieldNumber = 3;
  inline const ::std::string& variable() const;
  inline void set_variable(const ::std::string& value);
  inline void set_variable(const char* value);
  inline void set_variable(const char* value, size_t size);
  inline ::std::string* mutable_variable();
  inline ::std::string* release_variable();
  inline void set_allocated_variable(::std::string* variable);

  // optional .Mysqlx.Datatypes.Scalar literal = 4;
  inline bool has_literal() const;
  inline void clear_literal();
  static const int kLiteralFieldNumber = 4;
  inline const ::Mysqlx::Datatypes::Scalar& literal() const;
  inline ::Mysqlx::Datatypes::Scalar* mutable_literal();
  inline ::Mysqlx::Datatypes::Scalar* release_literal();
  inline void set_allocated_literal(::Mysqlx::Datatypes::Scalar* literal);

  // optional .Mysqlx.Expr.FunctionCall function_call = 5;
  inline bool has_function_call() const;
  inline void clear_function_call();
  static const int kFunctionCallFieldNumber = 5;
  inline const ::Mysqlx::Expr::FunctionCall& function_call() const;
  inline ::Mysqlx::Expr::FunctionCall* mutable_function_call();
  inline ::Mysqlx::Expr::FunctionCall* release_function_call();
  inline void set_allocated_function_call(::Mysqlx::Expr::FunctionCall* function_call);

  // optional .Mysqlx.Expr.Operator operator = 6;
  inline bool has_operator_() const;
  inline void clear_operator_();
  static const int kOperatorFieldNumber = 6;
  inline const ::Mysqlx::Expr::Operator& operator_() const;
  inline ::Mysqlx::Expr::Operator* mutable_operator_();
  inline ::Mysqlx::Expr::Operator* release_operator_();
  inline void set_allocated_operator_(::Mysqlx::Expr::Operator* operator_);

  // optional uint32 position = 7;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 7;
  inline ::google::protobuf::uint32 position() const;
  inline void set_position(::google::protobuf::uint32 value);

  // optional .Mysqlx.Expr.Object object = 8;
  inline bool has_object() const;
  inline void clear_object();
  static const int kObjectFieldNumber = 8;
  inline const ::Mysqlx::Expr::Object& object() const;
  inline ::Mysqlx::Expr::Object* mutable_object();
  inline ::Mysqlx::Expr::Object* release_object();
  inline void set_allocated_object(::Mysqlx::Expr::Object* object);

  // optional .Mysqlx.Expr.Array array = 9;
  inline bool has_array() const;
  inline void clear_array();
  static const int kArrayFieldNumber = 9;
  inline const ::Mysqlx::Expr::Array& array() const;
  inline ::Mysqlx::Expr::Array* mutable_array();
  inline ::Mysqlx::Expr::Array* release_array();
  inline void set_allocated_array(::Mysqlx::Expr::Array* array);

  // @@protoc_insertion_point(class_scope:Mysqlx.Expr.Expr)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_identifier();
  inline void clear_has_identifier();
  inline void set_has_variable();
  inline void clear_has_variable();
  inline void set_has_literal();
  inline void clear_has_literal();
  inline void set_has_function_call();
  inline void clear_has_function_call();
  inline void set_has_operator_();
  inline void clear_has_operator_();
  inline void set_has_position();
  inline void clear_has_position();
  inline void set_has_object();
  inline void clear_has_object();
  inline void set_has_array();
  inline void clear_has_array();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::Mysqlx::Expr::ColumnIdentifier* identifier_;
  ::std::string* variable_;
  ::Mysqlx::Datatypes::Scalar* literal_;
  int type_;
  ::google::protobuf::uint32 position_;
  ::Mysqlx::Expr::FunctionCall* function_call_;
  ::Mysqlx::Expr::Operator* operator__;
  ::Mysqlx::Expr::Object* object_;
  ::Mysqlx::Expr::Array* array_;
  friend void  protobuf_AddDesc_mysqlx_5fexpr_2eproto();
  friend void protobuf_AssignDesc_mysqlx_5fexpr_2eproto();
  friend void protobuf_ShutdownFile_mysqlx_5fexpr_2eproto();

  void InitAsDefaultInstance();
  static Expr* default_instance_;
};
// -------------------------------------------------------------------

class Identifier : public ::google::protobuf::Message {
 public:
  Identifier();
  virtual ~Identifier();

  Identifier(const Identifier& from);

  inline Identifier& operator=(const Identifier& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Identifier& default_instance();

  void Swap(Identifier* other);

  // implements Message ----------------------------------------------

  Identifier* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Identifier& from);
  void MergeFrom(const Identifier& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string schema_name = 2;
  inline bool has_schema_name() const;
  inline void clear_schema_name();
  static const int kSchemaNameFieldNumber = 2;
  inline const ::std::string& schema_name() const;
  inline void set_schema_name(const ::std::string& value);
  inline void set_schema_name(const char* value);
  inline void set_schema_name(const char* value, size_t size);
  inline ::std::string* mutable_schema_name();
  inline ::std::string* release_schema_name();
  inline void set_allocated_schema_name(::std::string* schema_name);

  // @@protoc_insertion_point(class_scope:Mysqlx.Expr.Identifier)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_schema_name();
  inline void clear_has_schema_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::std::string* schema_name_;
  friend void  protobuf_AddDesc_mysqlx_5fexpr_2eproto();
  friend void protobuf_AssignDesc_mysqlx_5fexpr_2eproto();
  friend void protobuf_ShutdownFile_mysqlx_5fexpr_2eproto();

  void InitAsDefaultInstance();
  static Identifier* default_instance_;
};
// -------------------------------------------------------------------

class DocumentPathItem : public ::google::protobuf::Message {
 public:
  DocumentPathItem();
  virtual ~DocumentPathItem();

  DocumentPathItem(const DocumentPathItem& from);

  inline DocumentPathItem& operator=(const DocumentPathItem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DocumentPathItem& default_instance();

  void Swap(DocumentPathItem* other);

  // implements Message ----------------------------------------------

  DocumentPathItem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DocumentPathItem& from);
  void MergeFrom(const DocumentPathItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef DocumentPathItem_Type Type;
  static const Type MEMBER = DocumentPathItem_Type_MEMBER;
  static const Type MEMBER_ASTERISK = DocumentPathItem_Type_MEMBER_ASTERISK;
  static const Type ARRAY_INDEX = DocumentPathItem_Type_ARRAY_INDEX;
  static const Type ARRAY_INDEX_ASTERISK = DocumentPathItem_Type_ARRAY_INDEX_ASTERISK;
  static const Type DOUBLE_ASTERISK = DocumentPathItem_Type_DOUBLE_ASTERISK;
  static inline bool Type_IsValid(int value) {
    return DocumentPathItem_Type_IsValid(value);
  }
  static const Type Type_MIN =
    DocumentPathItem_Type_Type_MIN;
  static const Type Type_MAX =
    DocumentPathItem_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    DocumentPathItem_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return DocumentPathItem_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return DocumentPathItem_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return DocumentPathItem_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .Mysqlx.Expr.DocumentPathItem.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::Mysqlx::Expr::DocumentPathItem_Type type() const;
  inline void set_type(::Mysqlx::Expr::DocumentPathItem_Type value);

  // optional string value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // optional uint32 index = 3;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 3;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Mysqlx.Expr.DocumentPathItem)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_index();
  inline void clear_has_index();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* value_;
  int type_;
  ::google::protobuf::uint32 index_;
  friend void  protobuf_AddDesc_mysqlx_5fexpr_2eproto();
  friend void protobuf_AssignDesc_mysqlx_5fexpr_2eproto();
  friend void protobuf_ShutdownFile_mysqlx_5fexpr_2eproto();

  void InitAsDefaultInstance();
  static DocumentPathItem* default_instance_;
};
// -------------------------------------------------------------------

class ColumnIdentifier : public ::google::protobuf::Message {
 public:
  ColumnIdentifier();
  virtual ~ColumnIdentifier();

  ColumnIdentifier(const ColumnIdentifier& from);

  inline ColumnIdentifier& operator=(const ColumnIdentifier& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ColumnIdentifier& default_instance();

  void Swap(ColumnIdentifier* other);

  // implements Message ----------------------------------------------

  ColumnIdentifier* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ColumnIdentifier& from);
  void MergeFrom(const ColumnIdentifier& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Mysqlx.Expr.DocumentPathItem document_path = 1;
  inline int document_path_size() const;
  inline void clear_document_path();
  static const int kDocumentPathFieldNumber = 1;
  inline const ::Mysqlx::Expr::DocumentPathItem& document_path(int index) const;
  inline ::Mysqlx::Expr::DocumentPathItem* mutable_document_path(int index);
  inline ::Mysqlx::Expr::DocumentPathItem* add_document_path();
  inline const ::google::protobuf::RepeatedPtrField< ::Mysqlx::Expr::DocumentPathItem >&
      document_path() const;
  inline ::google::protobuf::RepeatedPtrField< ::Mysqlx::Expr::DocumentPathItem >*
      mutable_document_path();

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string table_name = 3;
  inline bool has_table_name() const;
  inline void clear_table_name();
  static const int kTableNameFieldNumber = 3;
  inline const ::std::string& table_name() const;
  inline void set_table_name(const ::std::string& value);
  inline void set_table_name(const char* value);
  inline void set_table_name(const char* value, size_t size);
  inline ::std::string* mutable_table_name();
  inline ::std::string* release_table_name();
  inline void set_allocated_table_name(::std::string* table_name);

  // optional string schema_name = 4;
  inline bool has_schema_name() const;
  inline void clear_schema_name();
  static const int kSchemaNameFieldNumber = 4;
  inline const ::std::string& schema_name() const;
  inline void set_schema_name(const ::std::string& value);
  inline void set_schema_name(const char* value);
  inline void set_schema_name(const char* value, size_t size);
  inline ::std::string* mutable_schema_name();
  inline ::std::string* release_schema_name();
  inline void set_allocated_schema_name(::std::string* schema_name);

  // @@protoc_insertion_point(class_scope:Mysqlx.Expr.ColumnIdentifier)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_table_name();
  inline void clear_has_table_name();
  inline void set_has_schema_name();
  inline void clear_has_schema_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::Mysqlx::Expr::DocumentPathItem > document_path_;
  ::std::string* name_;
  ::std::string* table_name_;
  ::std::string* schema_name_;
  friend void  protobuf_AddDesc_mysqlx_5fexpr_2eproto();
  friend void protobuf_AssignDesc_mysqlx_5fexpr_2eproto();
  friend void protobuf_ShutdownFile_mysqlx_5fexpr_2eproto();

  void InitAsDefaultInstance();
  static ColumnIdentifier* default_instance_;
};
// -------------------------------------------------------------------

class FunctionCall : public ::google::protobuf::Message {
 public:
  FunctionCall();
  virtual ~FunctionCall();

  FunctionCall(const FunctionCall& from);

  inline FunctionCall& operator=(const FunctionCall& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FunctionCall& default_instance();

  void Swap(FunctionCall* other);

  // implements Message ----------------------------------------------

  FunctionCall* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FunctionCall& from);
  void MergeFrom(const FunctionCall& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Mysqlx.Expr.Identifier name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::Mysqlx::Expr::Identifier& name() const;
  inline ::Mysqlx::Expr::Identifier* mutable_name();
  inline ::Mysqlx::Expr::Identifier* release_name();
  inline void set_allocated_name(::Mysqlx::Expr::Identifier* name);

  // repeated .Mysqlx.Expr.Expr param = 2;
  inline int param_size() const;
  inline void clear_param();
  static const int kParamFieldNumber = 2;
  inline const ::Mysqlx::Expr::Expr& param(int index) const;
  inline ::Mysqlx::Expr::Expr* mutable_param(int index);
  inline ::Mysqlx::Expr::Expr* add_param();
  inline const ::google::protobuf::RepeatedPtrField< ::Mysqlx::Expr::Expr >&
      param() const;
  inline ::google::protobuf::RepeatedPtrField< ::Mysqlx::Expr::Expr >*
      mutable_param();

  // @@protoc_insertion_point(class_scope:Mysqlx.Expr.FunctionCall)
 private:
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::Mysqlx::Expr::Identifier* name_;
  ::google::protobuf::RepeatedPtrField< ::Mysqlx::Expr::Expr > param_;
  friend void  protobuf_AddDesc_mysqlx_5fexpr_2eproto();
  friend void protobuf_AssignDesc_mysqlx_5fexpr_2eproto();
  friend void protobuf_ShutdownFile_mysqlx_5fexpr_2eproto();

  void InitAsDefaultInstance();
  static FunctionCall* default_instance_;
};
// -------------------------------------------------------------------

class Operator : public ::google::protobuf::Message {
 public:
  Operator();
  virtual ~Operator();

  Operator(const Operator& from);

  inline Operator& operator=(const Operator& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Operator& default_instance();

  void Swap(Operator* other);

  // implements Message ----------------------------------------------

  Operator* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Operator& from);
  void MergeFrom(const Operator& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // repeated .Mysqlx.Expr.Expr param = 2;
  inline int param_size() const;
  inline void clear_param();
  static const int kParamFieldNumber = 2;
  inline const ::Mysqlx::Expr::Expr& param(int index) const;
  inline ::Mysqlx::Expr::Expr* mutable_param(int index);
  inline ::Mysqlx::Expr::Expr* add_param();
  inline const ::google::protobuf::RepeatedPtrField< ::Mysqlx::Expr::Expr >&
      param() const;
  inline ::google::protobuf::RepeatedPtrField< ::Mysqlx::Expr::Expr >*
      mutable_param();

  // @@protoc_insertion_point(class_scope:Mysqlx.Expr.Operator)
 private:
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::google::protobuf::RepeatedPtrField< ::Mysqlx::Expr::Expr > param_;
  friend void  protobuf_AddDesc_mysqlx_5fexpr_2eproto();
  friend void protobuf_AssignDesc_mysqlx_5fexpr_2eproto();
  friend void protobuf_ShutdownFile_mysqlx_5fexpr_2eproto();

  void InitAsDefaultInstance();
  static Operator* default_instance_;
};
// -------------------------------------------------------------------

class Object_ObjectField : public ::google::protobuf::Message {
 public:
  Object_ObjectField();
  virtual ~Object_ObjectField();

  Object_ObjectField(const Object_ObjectField& from);

  inline Object_ObjectField& operator=(const Object_ObjectField& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Object_ObjectField& default_instance();

  void Swap(Object_ObjectField* other);

  // implements Message ----------------------------------------------

  Object_ObjectField* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Object_ObjectField& from);
  void MergeFrom(const Object_ObjectField& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // required .Mysqlx.Expr.Expr value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::Mysqlx::Expr::Expr& value() const;
  inline ::Mysqlx::Expr::Expr* mutable_value();
  inline ::Mysqlx::Expr::Expr* release_value();
  inline void set_allocated_value(::Mysqlx::Expr::Expr* value);

  // @@protoc_insertion_point(class_scope:Mysqlx.Expr.Object.ObjectField)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* key_;
  ::Mysqlx::Expr::Expr* value_;
  friend void  protobuf_AddDesc_mysqlx_5fexpr_2eproto();
  friend void protobuf_AssignDesc_mysqlx_5fexpr_2eproto();
  friend void protobuf_ShutdownFile_mysqlx_5fexpr_2eproto();

  void InitAsDefaultInstance();
  static Object_ObjectField* default_instance_;
};
// -------------------------------------------------------------------

class Object : public ::google::protobuf::Message {
 public:
  Object();
  virtual ~Object();

  Object(const Object& from);

  inline Object& operator=(const Object& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Object& default_instance();

  void Swap(Object* other);

  // implements Message ----------------------------------------------

  Object* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Object& from);
  void MergeFrom(const Object& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Object_ObjectField ObjectField;

  // accessors -------------------------------------------------------

  // repeated .Mysqlx.Expr.Object.ObjectField fld = 1;
  inline int fld_size() const;
  inline void clear_fld();
  static const int kFldFieldNumber = 1;
  inline const ::Mysqlx::Expr::Object_ObjectField& fld(int index) const;
  inline ::Mysqlx::Expr::Object_ObjectField* mutable_fld(int index);
  inline ::Mysqlx::Expr::Object_ObjectField* add_fld();
  inline const ::google::protobuf::RepeatedPtrField< ::Mysqlx::Expr::Object_ObjectField >&
      fld() const;
  inline ::google::protobuf::RepeatedPtrField< ::Mysqlx::Expr::Object_ObjectField >*
      mutable_fld();

  // @@protoc_insertion_point(class_scope:Mysqlx.Expr.Object)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::Mysqlx::Expr::Object_ObjectField > fld_;
  friend void  protobuf_AddDesc_mysqlx_5fexpr_2eproto();
  friend void protobuf_AssignDesc_mysqlx_5fexpr_2eproto();
  friend void protobuf_ShutdownFile_mysqlx_5fexpr_2eproto();

  void InitAsDefaultInstance();
  static Object* default_instance_;
};
// -------------------------------------------------------------------

class Array : public ::google::protobuf::Message {
 public:
  Array();
  virtual ~Array();

  Array(const Array& from);

  inline Array& operator=(const Array& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Array& default_instance();

  void Swap(Array* other);

  // implements Message ----------------------------------------------

  Array* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Array& from);
  void MergeFrom(const Array& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Mysqlx.Expr.Expr value = 1;
  inline int value_size() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline const ::Mysqlx::Expr::Expr& value(int index) const;
  inline ::Mysqlx::Expr::Expr* mutable_value(int index);
  inline ::Mysqlx::Expr::Expr* add_value();
  inline const ::google::protobuf::RepeatedPtrField< ::Mysqlx::Expr::Expr >&
      value() const;
  inline ::google::protobuf::RepeatedPtrField< ::Mysqlx::Expr::Expr >*
      mutable_value();

  // @@protoc_insertion_point(class_scope:Mysqlx.Expr.Array)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::Mysqlx::Expr::Expr > value_;
  friend void  protobuf_AddDesc_mysqlx_5fexpr_2eproto();
  friend void protobuf_AssignDesc_mysqlx_5fexpr_2eproto();
  friend void protobuf_ShutdownFile_mysqlx_5fexpr_2eproto();

  void InitAsDefaultInstance();
  static Array* default_instance_;
};
// ===================================================================


// ===================================================================

// Expr

// required .Mysqlx.Expr.Expr.Type type = 1;
inline bool Expr::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Expr::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Expr::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Expr::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::Mysqlx::Expr::Expr_Type Expr::type() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Expr.Expr.type)
  return static_cast< ::Mysqlx::Expr::Expr_Type >(type_);
}
inline void Expr::set_type(::Mysqlx::Expr::Expr_Type value) {
  assert(::Mysqlx::Expr::Expr_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:Mysqlx.Expr.Expr.type)
}

// optional .Mysqlx.Expr.ColumnIdentifier identifier = 2;
inline bool Expr::has_identifier() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Expr::set_has_identifier() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Expr::clear_has_identifier() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Expr::clear_identifier() {
  if (identifier_ != NULL) identifier_->::Mysqlx::Expr::ColumnIdentifier::Clear();
  clear_has_identifier();
}
inline const ::Mysqlx::Expr::ColumnIdentifier& Expr::identifier() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Expr.Expr.identifier)
  return identifier_ != NULL ? *identifier_ : *default_instance_->identifier_;
}
inline ::Mysqlx::Expr::ColumnIdentifier* Expr::mutable_identifier() {
  set_has_identifier();
  if (identifier_ == NULL) identifier_ = new ::Mysqlx::Expr::ColumnIdentifier;
  // @@protoc_insertion_point(field_mutable:Mysqlx.Expr.Expr.identifier)
  return identifier_;
}
inline ::Mysqlx::Expr::ColumnIdentifier* Expr::release_identifier() {
  clear_has_identifier();
  ::Mysqlx::Expr::ColumnIdentifier* temp = identifier_;
  identifier_ = NULL;
  return temp;
}
inline void Expr::set_allocated_identifier(::Mysqlx::Expr::ColumnIdentifier* identifier) {
  delete identifier_;
  identifier_ = identifier;
  if (identifier) {
    set_has_identifier();
  } else {
    clear_has_identifier();
  }
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Expr.Expr.identifier)
}

// optional string variable = 3;
inline bool Expr::has_variable() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Expr::set_has_variable() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Expr::clear_has_variable() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Expr::clear_variable() {
  if (variable_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    variable_->clear();
  }
  clear_has_variable();
}
inline const ::std::string& Expr::variable() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Expr.Expr.variable)
  return *variable_;
}
inline void Expr::set_variable(const ::std::string& value) {
  set_has_variable();
  if (variable_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    variable_ = new ::std::string;
  }
  variable_->assign(value);
  // @@protoc_insertion_point(field_set:Mysqlx.Expr.Expr.variable)
}
inline void Expr::set_variable(const char* value) {
  set_has_variable();
  if (variable_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    variable_ = new ::std::string;
  }
  variable_->assign(value);
  // @@protoc_insertion_point(field_set_char:Mysqlx.Expr.Expr.variable)
}
inline void Expr::set_variable(const char* value, size_t size) {
  set_has_variable();
  if (variable_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    variable_ = new ::std::string;
  }
  variable_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Mysqlx.Expr.Expr.variable)
}
inline ::std::string* Expr::mutable_variable() {
  set_has_variable();
  if (variable_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    variable_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Mysqlx.Expr.Expr.variable)
  return variable_;
}
inline ::std::string* Expr::release_variable() {
  clear_has_variable();
  if (variable_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = variable_;
    variable_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Expr::set_allocated_variable(::std::string* variable) {
  if (variable_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete variable_;
  }
  if (variable) {
    set_has_variable();
    variable_ = variable;
  } else {
    clear_has_variable();
    variable_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Expr.Expr.variable)
}

// optional .Mysqlx.Datatypes.Scalar literal = 4;
inline bool Expr::has_literal() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Expr::set_has_literal() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Expr::clear_has_literal() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Expr::clear_literal() {
  if (literal_ != NULL) literal_->::Mysqlx::Datatypes::Scalar::Clear();
  clear_has_literal();
}
inline const ::Mysqlx::Datatypes::Scalar& Expr::literal() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Expr.Expr.literal)
  return literal_ != NULL ? *literal_ : *default_instance_->literal_;
}
inline ::Mysqlx::Datatypes::Scalar* Expr::mutable_literal() {
  set_has_literal();
  if (literal_ == NULL) literal_ = new ::Mysqlx::Datatypes::Scalar;
  // @@protoc_insertion_point(field_mutable:Mysqlx.Expr.Expr.literal)
  return literal_;
}
inline ::Mysqlx::Datatypes::Scalar* Expr::release_literal() {
  clear_has_literal();
  ::Mysqlx::Datatypes::Scalar* temp = literal_;
  literal_ = NULL;
  return temp;
}
inline void Expr::set_allocated_literal(::Mysqlx::Datatypes::Scalar* literal) {
  delete literal_;
  literal_ = literal;
  if (literal) {
    set_has_literal();
  } else {
    clear_has_literal();
  }
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Expr.Expr.literal)
}

// optional .Mysqlx.Expr.FunctionCall function_call = 5;
inline bool Expr::has_function_call() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Expr::set_has_function_call() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Expr::clear_has_function_call() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Expr::clear_function_call() {
  if (function_call_ != NULL) function_call_->::Mysqlx::Expr::FunctionCall::Clear();
  clear_has_function_call();
}
inline const ::Mysqlx::Expr::FunctionCall& Expr::function_call() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Expr.Expr.function_call)
  return function_call_ != NULL ? *function_call_ : *default_instance_->function_call_;
}
inline ::Mysqlx::Expr::FunctionCall* Expr::mutable_function_call() {
  set_has_function_call();
  if (function_call_ == NULL) function_call_ = new ::Mysqlx::Expr::FunctionCall;
  // @@protoc_insertion_point(field_mutable:Mysqlx.Expr.Expr.function_call)
  return function_call_;
}
inline ::Mysqlx::Expr::FunctionCall* Expr::release_function_call() {
  clear_has_function_call();
  ::Mysqlx::Expr::FunctionCall* temp = function_call_;
  function_call_ = NULL;
  return temp;
}
inline void Expr::set_allocated_function_call(::Mysqlx::Expr::FunctionCall* function_call) {
  delete function_call_;
  function_call_ = function_call;
  if (function_call) {
    set_has_function_call();
  } else {
    clear_has_function_call();
  }
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Expr.Expr.function_call)
}

// optional .Mysqlx.Expr.Operator operator = 6;
inline bool Expr::has_operator_() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Expr::set_has_operator_() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Expr::clear_has_operator_() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Expr::clear_operator_() {
  if (operator__ != NULL) operator__->::Mysqlx::Expr::Operator::Clear();
  clear_has_operator_();
}
inline const ::Mysqlx::Expr::Operator& Expr::operator_() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Expr.Expr.operator)
  return operator__ != NULL ? *operator__ : *default_instance_->operator__;
}
inline ::Mysqlx::Expr::Operator* Expr::mutable_operator_() {
  set_has_operator_();
  if (operator__ == NULL) operator__ = new ::Mysqlx::Expr::Operator;
  // @@protoc_insertion_point(field_mutable:Mysqlx.Expr.Expr.operator)
  return operator__;
}
inline ::Mysqlx::Expr::Operator* Expr::release_operator_() {
  clear_has_operator_();
  ::Mysqlx::Expr::Operator* temp = operator__;
  operator__ = NULL;
  return temp;
}
inline void Expr::set_allocated_operator_(::Mysqlx::Expr::Operator* operator_) {
  delete operator__;
  operator__ = operator_;
  if (operator_) {
    set_has_operator_();
  } else {
    clear_has_operator_();
  }
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Expr.Expr.operator)
}

// optional uint32 position = 7;
inline bool Expr::has_position() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Expr::set_has_position() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Expr::clear_has_position() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Expr::clear_position() {
  position_ = 0u;
  clear_has_position();
}
inline ::google::protobuf::uint32 Expr::position() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Expr.Expr.position)
  return position_;
}
inline void Expr::set_position(::google::protobuf::uint32 value) {
  set_has_position();
  position_ = value;
  // @@protoc_insertion_point(field_set:Mysqlx.Expr.Expr.position)
}

// optional .Mysqlx.Expr.Object object = 8;
inline bool Expr::has_object() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Expr::set_has_object() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Expr::clear_has_object() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Expr::clear_object() {
  if (object_ != NULL) object_->::Mysqlx::Expr::Object::Clear();
  clear_has_object();
}
inline const ::Mysqlx::Expr::Object& Expr::object() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Expr.Expr.object)
  return object_ != NULL ? *object_ : *default_instance_->object_;
}
inline ::Mysqlx::Expr::Object* Expr::mutable_object() {
  set_has_object();
  if (object_ == NULL) object_ = new ::Mysqlx::Expr::Object;
  // @@protoc_insertion_point(field_mutable:Mysqlx.Expr.Expr.object)
  return object_;
}
inline ::Mysqlx::Expr::Object* Expr::release_object() {
  clear_has_object();
  ::Mysqlx::Expr::Object* temp = object_;
  object_ = NULL;
  return temp;
}
inline void Expr::set_allocated_object(::Mysqlx::Expr::Object* object) {
  delete object_;
  object_ = object;
  if (object) {
    set_has_object();
  } else {
    clear_has_object();
  }
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Expr.Expr.object)
}

// optional .Mysqlx.Expr.Array array = 9;
inline bool Expr::has_array() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Expr::set_has_array() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Expr::clear_has_array() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Expr::clear_array() {
  if (array_ != NULL) array_->::Mysqlx::Expr::Array::Clear();
  clear_has_array();
}
inline const ::Mysqlx::Expr::Array& Expr::array() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Expr.Expr.array)
  return array_ != NULL ? *array_ : *default_instance_->array_;
}
inline ::Mysqlx::Expr::Array* Expr::mutable_array() {
  set_has_array();
  if (array_ == NULL) array_ = new ::Mysqlx::Expr::Array;
  // @@protoc_insertion_point(field_mutable:Mysqlx.Expr.Expr.array)
  return array_;
}
inline ::Mysqlx::Expr::Array* Expr::release_array() {
  clear_has_array();
  ::Mysqlx::Expr::Array* temp = array_;
  array_ = NULL;
  return temp;
}
inline void Expr::set_allocated_array(::Mysqlx::Expr::Array* array) {
  delete array_;
  array_ = array;
  if (array) {
    set_has_array();
  } else {
    clear_has_array();
  }
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Expr.Expr.array)
}

// -------------------------------------------------------------------

// Identifier

// required string name = 1;
inline bool Identifier::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Identifier::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Identifier::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Identifier::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Identifier::name() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Expr.Identifier.name)
  return *name_;
}
inline void Identifier::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:Mysqlx.Expr.Identifier.name)
}
inline void Identifier::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:Mysqlx.Expr.Identifier.name)
}
inline void Identifier::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Mysqlx.Expr.Identifier.name)
}
inline ::std::string* Identifier::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Mysqlx.Expr.Identifier.name)
  return name_;
}
inline ::std::string* Identifier::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Identifier::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Expr.Identifier.name)
}

// optional string schema_name = 2;
inline bool Identifier::has_schema_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Identifier::set_has_schema_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Identifier::clear_has_schema_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Identifier::clear_schema_name() {
  if (schema_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    schema_name_->clear();
  }
  clear_has_schema_name();
}
inline const ::std::string& Identifier::schema_name() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Expr.Identifier.schema_name)
  return *schema_name_;
}
inline void Identifier::set_schema_name(const ::std::string& value) {
  set_has_schema_name();
  if (schema_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    schema_name_ = new ::std::string;
  }
  schema_name_->assign(value);
  // @@protoc_insertion_point(field_set:Mysqlx.Expr.Identifier.schema_name)
}
inline void Identifier::set_schema_name(const char* value) {
  set_has_schema_name();
  if (schema_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    schema_name_ = new ::std::string;
  }
  schema_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:Mysqlx.Expr.Identifier.schema_name)
}
inline void Identifier::set_schema_name(const char* value, size_t size) {
  set_has_schema_name();
  if (schema_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    schema_name_ = new ::std::string;
  }
  schema_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Mysqlx.Expr.Identifier.schema_name)
}
inline ::std::string* Identifier::mutable_schema_name() {
  set_has_schema_name();
  if (schema_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    schema_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Mysqlx.Expr.Identifier.schema_name)
  return schema_name_;
}
inline ::std::string* Identifier::release_schema_name() {
  clear_has_schema_name();
  if (schema_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = schema_name_;
    schema_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Identifier::set_allocated_schema_name(::std::string* schema_name) {
  if (schema_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete schema_name_;
  }
  if (schema_name) {
    set_has_schema_name();
    schema_name_ = schema_name;
  } else {
    clear_has_schema_name();
    schema_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Expr.Identifier.schema_name)
}

// -------------------------------------------------------------------

// DocumentPathItem

// required .Mysqlx.Expr.DocumentPathItem.Type type = 1;
inline bool DocumentPathItem::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DocumentPathItem::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DocumentPathItem::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DocumentPathItem::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::Mysqlx::Expr::DocumentPathItem_Type DocumentPathItem::type() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Expr.DocumentPathItem.type)
  return static_cast< ::Mysqlx::Expr::DocumentPathItem_Type >(type_);
}
inline void DocumentPathItem::set_type(::Mysqlx::Expr::DocumentPathItem_Type value) {
  assert(::Mysqlx::Expr::DocumentPathItem_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:Mysqlx.Expr.DocumentPathItem.type)
}

// optional string value = 2;
inline bool DocumentPathItem::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DocumentPathItem::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DocumentPathItem::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DocumentPathItem::clear_value() {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& DocumentPathItem::value() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Expr.DocumentPathItem.value)
  return *value_;
}
inline void DocumentPathItem::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(value);
  // @@protoc_insertion_point(field_set:Mysqlx.Expr.DocumentPathItem.value)
}
inline void DocumentPathItem::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(value);
  // @@protoc_insertion_point(field_set_char:Mysqlx.Expr.DocumentPathItem.value)
}
inline void DocumentPathItem::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Mysqlx.Expr.DocumentPathItem.value)
}
inline ::std::string* DocumentPathItem::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Mysqlx.Expr.DocumentPathItem.value)
  return value_;
}
inline ::std::string* DocumentPathItem::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DocumentPathItem::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Expr.DocumentPathItem.value)
}

// optional uint32 index = 3;
inline bool DocumentPathItem::has_index() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DocumentPathItem::set_has_index() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DocumentPathItem::clear_has_index() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DocumentPathItem::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 DocumentPathItem::index() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Expr.DocumentPathItem.index)
  return index_;
}
inline void DocumentPathItem::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
  // @@protoc_insertion_point(field_set:Mysqlx.Expr.DocumentPathItem.index)
}

// -------------------------------------------------------------------

// ColumnIdentifier

// repeated .Mysqlx.Expr.DocumentPathItem document_path = 1;
inline int ColumnIdentifier::document_path_size() const {
  return document_path_.size();
}
inline void ColumnIdentifier::clear_document_path() {
  document_path_.Clear();
}
inline const ::Mysqlx::Expr::DocumentPathItem& ColumnIdentifier::document_path(int index) const {
  // @@protoc_insertion_point(field_get:Mysqlx.Expr.ColumnIdentifier.document_path)
  return document_path_.Get(index);
}
inline ::Mysqlx::Expr::DocumentPathItem* ColumnIdentifier::mutable_document_path(int index) {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Expr.ColumnIdentifier.document_path)
  return document_path_.Mutable(index);
}
inline ::Mysqlx::Expr::DocumentPathItem* ColumnIdentifier::add_document_path() {
  // @@protoc_insertion_point(field_add:Mysqlx.Expr.ColumnIdentifier.document_path)
  return document_path_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Mysqlx::Expr::DocumentPathItem >&
ColumnIdentifier::document_path() const {
  // @@protoc_insertion_point(field_list:Mysqlx.Expr.ColumnIdentifier.document_path)
  return document_path_;
}
inline ::google::protobuf::RepeatedPtrField< ::Mysqlx::Expr::DocumentPathItem >*
ColumnIdentifier::mutable_document_path() {
  // @@protoc_insertion_point(field_mutable_list:Mysqlx.Expr.ColumnIdentifier.document_path)
  return &document_path_;
}

// optional string name = 2;
inline bool ColumnIdentifier::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ColumnIdentifier::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ColumnIdentifier::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ColumnIdentifier::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ColumnIdentifier::name() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Expr.ColumnIdentifier.name)
  return *name_;
}
inline void ColumnIdentifier::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:Mysqlx.Expr.ColumnIdentifier.name)
}
inline void ColumnIdentifier::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:Mysqlx.Expr.ColumnIdentifier.name)
}
inline void ColumnIdentifier::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Mysqlx.Expr.ColumnIdentifier.name)
}
inline ::std::string* ColumnIdentifier::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Mysqlx.Expr.ColumnIdentifier.name)
  return name_;
}
inline ::std::string* ColumnIdentifier::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ColumnIdentifier::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Expr.ColumnIdentifier.name)
}

// optional string table_name = 3;
inline bool ColumnIdentifier::has_table_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ColumnIdentifier::set_has_table_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ColumnIdentifier::clear_has_table_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ColumnIdentifier::clear_table_name() {
  if (table_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    table_name_->clear();
  }
  clear_has_table_name();
}
inline const ::std::string& ColumnIdentifier::table_name() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Expr.ColumnIdentifier.table_name)
  return *table_name_;
}
inline void ColumnIdentifier::set_table_name(const ::std::string& value) {
  set_has_table_name();
  if (table_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    table_name_ = new ::std::string;
  }
  table_name_->assign(value);
  // @@protoc_insertion_point(field_set:Mysqlx.Expr.ColumnIdentifier.table_name)
}
inline void ColumnIdentifier::set_table_name(const char* value) {
  set_has_table_name();
  if (table_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    table_name_ = new ::std::string;
  }
  table_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:Mysqlx.Expr.ColumnIdentifier.table_name)
}
inline void ColumnIdentifier::set_table_name(const char* value, size_t size) {
  set_has_table_name();
  if (table_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    table_name_ = new ::std::string;
  }
  table_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Mysqlx.Expr.ColumnIdentifier.table_name)
}
inline ::std::string* ColumnIdentifier::mutable_table_name() {
  set_has_table_name();
  if (table_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    table_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Mysqlx.Expr.ColumnIdentifier.table_name)
  return table_name_;
}
inline ::std::string* ColumnIdentifier::release_table_name() {
  clear_has_table_name();
  if (table_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = table_name_;
    table_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ColumnIdentifier::set_allocated_table_name(::std::string* table_name) {
  if (table_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete table_name_;
  }
  if (table_name) {
    set_has_table_name();
    table_name_ = table_name;
  } else {
    clear_has_table_name();
    table_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Expr.ColumnIdentifier.table_name)
}

// optional string schema_name = 4;
inline bool ColumnIdentifier::has_schema_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ColumnIdentifier::set_has_schema_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ColumnIdentifier::clear_has_schema_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ColumnIdentifier::clear_schema_name() {
  if (schema_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    schema_name_->clear();
  }
  clear_has_schema_name();
}
inline const ::std::string& ColumnIdentifier::schema_name() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Expr.ColumnIdentifier.schema_name)
  return *schema_name_;
}
inline void ColumnIdentifier::set_schema_name(const ::std::string& value) {
  set_has_schema_name();
  if (schema_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    schema_name_ = new ::std::string;
  }
  schema_name_->assign(value);
  // @@protoc_insertion_point(field_set:Mysqlx.Expr.ColumnIdentifier.schema_name)
}
inline void ColumnIdentifier::set_schema_name(const char* value) {
  set_has_schema_name();
  if (schema_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    schema_name_ = new ::std::string;
  }
  schema_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:Mysqlx.Expr.ColumnIdentifier.schema_name)
}
inline void ColumnIdentifier::set_schema_name(const char* value, size_t size) {
  set_has_schema_name();
  if (schema_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    schema_name_ = new ::std::string;
  }
  schema_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Mysqlx.Expr.ColumnIdentifier.schema_name)
}
inline ::std::string* ColumnIdentifier::mutable_schema_name() {
  set_has_schema_name();
  if (schema_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    schema_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Mysqlx.Expr.ColumnIdentifier.schema_name)
  return schema_name_;
}
inline ::std::string* ColumnIdentifier::release_schema_name() {
  clear_has_schema_name();
  if (schema_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = schema_name_;
    schema_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ColumnIdentifier::set_allocated_schema_name(::std::string* schema_name) {
  if (schema_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete schema_name_;
  }
  if (schema_name) {
    set_has_schema_name();
    schema_name_ = schema_name;
  } else {
    clear_has_schema_name();
    schema_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Expr.ColumnIdentifier.schema_name)
}

// -------------------------------------------------------------------

// FunctionCall

// required .Mysqlx.Expr.Identifier name = 1;
inline bool FunctionCall::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FunctionCall::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FunctionCall::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FunctionCall::clear_name() {
  if (name_ != NULL) name_->::Mysqlx::Expr::Identifier::Clear();
  clear_has_name();
}
inline const ::Mysqlx::Expr::Identifier& FunctionCall::name() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Expr.FunctionCall.name)
  return name_ != NULL ? *name_ : *default_instance_->name_;
}
inline ::Mysqlx::Expr::Identifier* FunctionCall::mutable_name() {
  set_has_name();
  if (name_ == NULL) name_ = new ::Mysqlx::Expr::Identifier;
  // @@protoc_insertion_point(field_mutable:Mysqlx.Expr.FunctionCall.name)
  return name_;
}
inline ::Mysqlx::Expr::Identifier* FunctionCall::release_name() {
  clear_has_name();
  ::Mysqlx::Expr::Identifier* temp = name_;
  name_ = NULL;
  return temp;
}
inline void FunctionCall::set_allocated_name(::Mysqlx::Expr::Identifier* name) {
  delete name_;
  name_ = name;
  if (name) {
    set_has_name();
  } else {
    clear_has_name();
  }
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Expr.FunctionCall.name)
}

// repeated .Mysqlx.Expr.Expr param = 2;
inline int FunctionCall::param_size() const {
  return param_.size();
}
inline void FunctionCall::clear_param() {
  param_.Clear();
}
inline const ::Mysqlx::Expr::Expr& FunctionCall::param(int index) const {
  // @@protoc_insertion_point(field_get:Mysqlx.Expr.FunctionCall.param)
  return param_.Get(index);
}
inline ::Mysqlx::Expr::Expr* FunctionCall::mutable_param(int index) {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Expr.FunctionCall.param)
  return param_.Mutable(index);
}
inline ::Mysqlx::Expr::Expr* FunctionCall::add_param() {
  // @@protoc_insertion_point(field_add:Mysqlx.Expr.FunctionCall.param)
  return param_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Mysqlx::Expr::Expr >&
FunctionCall::param() const {
  // @@protoc_insertion_point(field_list:Mysqlx.Expr.FunctionCall.param)
  return param_;
}
inline ::google::protobuf::RepeatedPtrField< ::Mysqlx::Expr::Expr >*
FunctionCall::mutable_param() {
  // @@protoc_insertion_point(field_mutable_list:Mysqlx.Expr.FunctionCall.param)
  return &param_;
}

// -------------------------------------------------------------------

// Operator

// required string name = 1;
inline bool Operator::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Operator::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Operator::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Operator::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Operator::name() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Expr.Operator.name)
  return *name_;
}
inline void Operator::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:Mysqlx.Expr.Operator.name)
}
inline void Operator::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:Mysqlx.Expr.Operator.name)
}
inline void Operator::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Mysqlx.Expr.Operator.name)
}
inline ::std::string* Operator::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Mysqlx.Expr.Operator.name)
  return name_;
}
inline ::std::string* Operator::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Operator::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Expr.Operator.name)
}

// repeated .Mysqlx.Expr.Expr param = 2;
inline int Operator::param_size() const {
  return param_.size();
}
inline void Operator::clear_param() {
  param_.Clear();
}
inline const ::Mysqlx::Expr::Expr& Operator::param(int index) const {
  // @@protoc_insertion_point(field_get:Mysqlx.Expr.Operator.param)
  return param_.Get(index);
}
inline ::Mysqlx::Expr::Expr* Operator::mutable_param(int index) {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Expr.Operator.param)
  return param_.Mutable(index);
}
inline ::Mysqlx::Expr::Expr* Operator::add_param() {
  // @@protoc_insertion_point(field_add:Mysqlx.Expr.Operator.param)
  return param_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Mysqlx::Expr::Expr >&
Operator::param() const {
  // @@protoc_insertion_point(field_list:Mysqlx.Expr.Operator.param)
  return param_;
}
inline ::google::protobuf::RepeatedPtrField< ::Mysqlx::Expr::Expr >*
Operator::mutable_param() {
  // @@protoc_insertion_point(field_mutable_list:Mysqlx.Expr.Operator.param)
  return &param_;
}

// -------------------------------------------------------------------

// Object_ObjectField

// required string key = 1;
inline bool Object_ObjectField::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Object_ObjectField::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Object_ObjectField::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Object_ObjectField::clear_key() {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& Object_ObjectField::key() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Expr.Object.ObjectField.key)
  return *key_;
}
inline void Object_ObjectField::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set:Mysqlx.Expr.Object.ObjectField.key)
}
inline void Object_ObjectField::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set_char:Mysqlx.Expr.Object.ObjectField.key)
}
inline void Object_ObjectField::set_key(const char* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Mysqlx.Expr.Object.ObjectField.key)
}
inline ::std::string* Object_ObjectField::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Mysqlx.Expr.Object.ObjectField.key)
  return key_;
}
inline ::std::string* Object_ObjectField::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Object_ObjectField::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Expr.Object.ObjectField.key)
}

// required .Mysqlx.Expr.Expr value = 2;
inline bool Object_ObjectField::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Object_ObjectField::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Object_ObjectField::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Object_ObjectField::clear_value() {
  if (value_ != NULL) value_->::Mysqlx::Expr::Expr::Clear();
  clear_has_value();
}
inline const ::Mysqlx::Expr::Expr& Object_ObjectField::value() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Expr.Object.ObjectField.value)
  return value_ != NULL ? *value_ : *default_instance_->value_;
}
inline ::Mysqlx::Expr::Expr* Object_ObjectField::mutable_value() {
  set_has_value();
  if (value_ == NULL) value_ = new ::Mysqlx::Expr::Expr;
  // @@protoc_insertion_point(field_mutable:Mysqlx.Expr.Object.ObjectField.value)
  return value_;
}
inline ::Mysqlx::Expr::Expr* Object_ObjectField::release_value() {
  clear_has_value();
  ::Mysqlx::Expr::Expr* temp = value_;
  value_ = NULL;
  return temp;
}
inline void Object_ObjectField::set_allocated_value(::Mysqlx::Expr::Expr* value) {
  delete value_;
  value_ = value;
  if (value) {
    set_has_value();
  } else {
    clear_has_value();
  }
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Expr.Object.ObjectField.value)
}

// -------------------------------------------------------------------

// Object

// repeated .Mysqlx.Expr.Object.ObjectField fld = 1;
inline int Object::fld_size() const {
  return fld_.size();
}
inline void Object::clear_fld() {
  fld_.Clear();
}
inline const ::Mysqlx::Expr::Object_ObjectField& Object::fld(int index) const {
  // @@protoc_insertion_point(field_get:Mysqlx.Expr.Object.fld)
  return fld_.Get(index);
}
inline ::Mysqlx::Expr::Object_ObjectField* Object::mutable_fld(int index) {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Expr.Object.fld)
  return fld_.Mutable(index);
}
inline ::Mysqlx::Expr::Object_ObjectField* Object::add_fld() {
  // @@protoc_insertion_point(field_add:Mysqlx.Expr.Object.fld)
  return fld_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Mysqlx::Expr::Object_ObjectField >&
Object::fld() const {
  // @@protoc_insertion_point(field_list:Mysqlx.Expr.Object.fld)
  return fld_;
}
inline ::google::protobuf::RepeatedPtrField< ::Mysqlx::Expr::Object_ObjectField >*
Object::mutable_fld() {
  // @@protoc_insertion_point(field_mutable_list:Mysqlx.Expr.Object.fld)
  return &fld_;
}

// -------------------------------------------------------------------

// Array

// repeated .Mysqlx.Expr.Expr value = 1;
inline int Array::value_size() const {
  return value_.size();
}
inline void Array::clear_value() {
  value_.Clear();
}
inline const ::Mysqlx::Expr::Expr& Array::value(int index) const {
  // @@protoc_insertion_point(field_get:Mysqlx.Expr.Array.value)
  return value_.Get(index);
}
inline ::Mysqlx::Expr::Expr* Array::mutable_value(int index) {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Expr.Array.value)
  return value_.Mutable(index);
}
inline ::Mysqlx::Expr::Expr* Array::add_value() {
  // @@protoc_insertion_point(field_add:Mysqlx.Expr.Array.value)
  return value_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Mysqlx::Expr::Expr >&
Array::value() const {
  // @@protoc_insertion_point(field_list:Mysqlx.Expr.Array.value)
  return value_;
}
inline ::google::protobuf::RepeatedPtrField< ::Mysqlx::Expr::Expr >*
Array::mutable_value() {
  // @@protoc_insertion_point(field_mutable_list:Mysqlx.Expr.Array.value)
  return &value_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace Expr
}  // namespace Mysqlx

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::Mysqlx::Expr::Expr_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Mysqlx::Expr::Expr_Type>() {
  return ::Mysqlx::Expr::Expr_Type_descriptor();
}
template <> struct is_proto_enum< ::Mysqlx::Expr::DocumentPathItem_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Mysqlx::Expr::DocumentPathItem_Type>() {
  return ::Mysqlx::Expr::DocumentPathItem_Type_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_mysqlx_5fexpr_2eproto__INCLUDED

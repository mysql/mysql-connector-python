/*
 * MySQL Connector/Python - MySQL driver written in Python.
 * Copyright (c) 2017, Oracle and/or its affiliates. All rights reserved.
 *
 * MySQL Connector/Python is licensed under the terms of the GPLv2
 * <http://www.gnu.org/licenses/old-licenses/gpl-2.0.html>, like most
 * MySQL Connectors. There are special exceptions to the terms and
 * conditions of the GPLv2 as it is applied to this software, see the
 * FOSS License Exception
 * <http://www.mysql.com/about/legal/licensing/foss-exception.html>.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
 */

// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mysqlx_crud.proto

#ifndef PROTOBUF_mysqlx_5fcrud_2eproto__INCLUDED
#define PROTOBUF_mysqlx_5fcrud_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "mysqlx_expr.pb.h"
#include "mysqlx_datatypes.pb.h"
// @@protoc_insertion_point(includes)

namespace Mysqlx {
namespace Crud {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_mysqlx_5fcrud_2eproto();
void protobuf_AssignDesc_mysqlx_5fcrud_2eproto();
void protobuf_ShutdownFile_mysqlx_5fcrud_2eproto();

class Column;
class Projection;
class Collection;
class Limit;
class Order;
class UpdateOperation;
class Find;
class Insert;
class Insert_TypedRow;
class Update;
class Delete;

enum Order_Direction {
  Order_Direction_ASC = 1,
  Order_Direction_DESC = 2
};
bool Order_Direction_IsValid(int value);
const Order_Direction Order_Direction_Direction_MIN = Order_Direction_ASC;
const Order_Direction Order_Direction_Direction_MAX = Order_Direction_DESC;
const int Order_Direction_Direction_ARRAYSIZE = Order_Direction_Direction_MAX + 1;

const ::google::protobuf::EnumDescriptor* Order_Direction_descriptor();
inline const ::std::string& Order_Direction_Name(Order_Direction value) {
  return ::google::protobuf::internal::NameOfEnum(
    Order_Direction_descriptor(), value);
}
inline bool Order_Direction_Parse(
    const ::std::string& name, Order_Direction* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Order_Direction>(
    Order_Direction_descriptor(), name, value);
}
enum UpdateOperation_UpdateType {
  UpdateOperation_UpdateType_SET = 1,
  UpdateOperation_UpdateType_ITEM_REMOVE = 2,
  UpdateOperation_UpdateType_ITEM_SET = 3,
  UpdateOperation_UpdateType_ITEM_REPLACE = 4,
  UpdateOperation_UpdateType_ITEM_MERGE = 5,
  UpdateOperation_UpdateType_ARRAY_INSERT = 6,
  UpdateOperation_UpdateType_ARRAY_APPEND = 7
};
bool UpdateOperation_UpdateType_IsValid(int value);
const UpdateOperation_UpdateType UpdateOperation_UpdateType_UpdateType_MIN = UpdateOperation_UpdateType_SET;
const UpdateOperation_UpdateType UpdateOperation_UpdateType_UpdateType_MAX = UpdateOperation_UpdateType_ARRAY_APPEND;
const int UpdateOperation_UpdateType_UpdateType_ARRAYSIZE = UpdateOperation_UpdateType_UpdateType_MAX + 1;

const ::google::protobuf::EnumDescriptor* UpdateOperation_UpdateType_descriptor();
inline const ::std::string& UpdateOperation_UpdateType_Name(UpdateOperation_UpdateType value) {
  return ::google::protobuf::internal::NameOfEnum(
    UpdateOperation_UpdateType_descriptor(), value);
}
inline bool UpdateOperation_UpdateType_Parse(
    const ::std::string& name, UpdateOperation_UpdateType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UpdateOperation_UpdateType>(
    UpdateOperation_UpdateType_descriptor(), name, value);
}
enum DataModel {
  DOCUMENT = 1,
  TABLE = 2
};
bool DataModel_IsValid(int value);
const DataModel DataModel_MIN = DOCUMENT;
const DataModel DataModel_MAX = TABLE;
const int DataModel_ARRAYSIZE = DataModel_MAX + 1;

const ::google::protobuf::EnumDescriptor* DataModel_descriptor();
inline const ::std::string& DataModel_Name(DataModel value) {
  return ::google::protobuf::internal::NameOfEnum(
    DataModel_descriptor(), value);
}
inline bool DataModel_Parse(
    const ::std::string& name, DataModel* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DataModel>(
    DataModel_descriptor(), name, value);
}
// ===================================================================

class Column : public ::google::protobuf::Message {
 public:
  Column();
  virtual ~Column();

  Column(const Column& from);

  inline Column& operator=(const Column& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Column& default_instance();

  void Swap(Column* other);

  // implements Message ----------------------------------------------

  Column* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Column& from);
  void MergeFrom(const Column& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string alias = 2;
  inline bool has_alias() const;
  inline void clear_alias();
  static const int kAliasFieldNumber = 2;
  inline const ::std::string& alias() const;
  inline void set_alias(const ::std::string& value);
  inline void set_alias(const char* value);
  inline void set_alias(const char* value, size_t size);
  inline ::std::string* mutable_alias();
  inline ::std::string* release_alias();
  inline void set_allocated_alias(::std::string* alias);

  // repeated .Mysqlx.Expr.DocumentPathItem document_path = 3;
  inline int document_path_size() const;
  inline void clear_document_path();
  static const int kDocumentPathFieldNumber = 3;
  inline const ::Mysqlx::Expr::DocumentPathItem& document_path(int index) const;
  inline ::Mysqlx::Expr::DocumentPathItem* mutable_document_path(int index);
  inline ::Mysqlx::Expr::DocumentPathItem* add_document_path();
  inline const ::google::protobuf::RepeatedPtrField< ::Mysqlx::Expr::DocumentPathItem >&
      document_path() const;
  inline ::google::protobuf::RepeatedPtrField< ::Mysqlx::Expr::DocumentPathItem >*
      mutable_document_path();

  // @@protoc_insertion_point(class_scope:Mysqlx.Crud.Column)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_alias();
  inline void clear_has_alias();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::std::string* alias_;
  ::google::protobuf::RepeatedPtrField< ::Mysqlx::Expr::DocumentPathItem > document_path_;
  friend void  protobuf_AddDesc_mysqlx_5fcrud_2eproto();
  friend void protobuf_AssignDesc_mysqlx_5fcrud_2eproto();
  friend void protobuf_ShutdownFile_mysqlx_5fcrud_2eproto();

  void InitAsDefaultInstance();
  static Column* default_instance_;
};
// -------------------------------------------------------------------

class Projection : public ::google::protobuf::Message {
 public:
  Projection();
  virtual ~Projection();

  Projection(const Projection& from);

  inline Projection& operator=(const Projection& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Projection& default_instance();

  void Swap(Projection* other);

  // implements Message ----------------------------------------------

  Projection* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Projection& from);
  void MergeFrom(const Projection& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Mysqlx.Expr.Expr source = 1;
  inline bool has_source() const;
  inline void clear_source();
  static const int kSourceFieldNumber = 1;
  inline const ::Mysqlx::Expr::Expr& source() const;
  inline ::Mysqlx::Expr::Expr* mutable_source();
  inline ::Mysqlx::Expr::Expr* release_source();
  inline void set_allocated_source(::Mysqlx::Expr::Expr* source);

  // optional string alias = 2;
  inline bool has_alias() const;
  inline void clear_alias();
  static const int kAliasFieldNumber = 2;
  inline const ::std::string& alias() const;
  inline void set_alias(const ::std::string& value);
  inline void set_alias(const char* value);
  inline void set_alias(const char* value, size_t size);
  inline ::std::string* mutable_alias();
  inline ::std::string* release_alias();
  inline void set_allocated_alias(::std::string* alias);

  // @@protoc_insertion_point(class_scope:Mysqlx.Crud.Projection)
 private:
  inline void set_has_source();
  inline void clear_has_source();
  inline void set_has_alias();
  inline void clear_has_alias();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::Mysqlx::Expr::Expr* source_;
  ::std::string* alias_;
  friend void  protobuf_AddDesc_mysqlx_5fcrud_2eproto();
  friend void protobuf_AssignDesc_mysqlx_5fcrud_2eproto();
  friend void protobuf_ShutdownFile_mysqlx_5fcrud_2eproto();

  void InitAsDefaultInstance();
  static Projection* default_instance_;
};
// -------------------------------------------------------------------

class Collection : public ::google::protobuf::Message {
 public:
  Collection();
  virtual ~Collection();

  Collection(const Collection& from);

  inline Collection& operator=(const Collection& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Collection& default_instance();

  void Swap(Collection* other);

  // implements Message ----------------------------------------------

  Collection* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Collection& from);
  void MergeFrom(const Collection& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string schema = 2;
  inline bool has_schema() const;
  inline void clear_schema();
  static const int kSchemaFieldNumber = 2;
  inline const ::std::string& schema() const;
  inline void set_schema(const ::std::string& value);
  inline void set_schema(const char* value);
  inline void set_schema(const char* value, size_t size);
  inline ::std::string* mutable_schema();
  inline ::std::string* release_schema();
  inline void set_allocated_schema(::std::string* schema);

  // @@protoc_insertion_point(class_scope:Mysqlx.Crud.Collection)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_schema();
  inline void clear_has_schema();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::std::string* schema_;
  friend void  protobuf_AddDesc_mysqlx_5fcrud_2eproto();
  friend void protobuf_AssignDesc_mysqlx_5fcrud_2eproto();
  friend void protobuf_ShutdownFile_mysqlx_5fcrud_2eproto();

  void InitAsDefaultInstance();
  static Collection* default_instance_;
};
// -------------------------------------------------------------------

class Limit : public ::google::protobuf::Message {
 public:
  Limit();
  virtual ~Limit();

  Limit(const Limit& from);

  inline Limit& operator=(const Limit& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Limit& default_instance();

  void Swap(Limit* other);

  // implements Message ----------------------------------------------

  Limit* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Limit& from);
  void MergeFrom(const Limit& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 row_count = 1;
  inline bool has_row_count() const;
  inline void clear_row_count();
  static const int kRowCountFieldNumber = 1;
  inline ::google::protobuf::uint64 row_count() const;
  inline void set_row_count(::google::protobuf::uint64 value);

  // optional uint64 offset = 2;
  inline bool has_offset() const;
  inline void clear_offset();
  static const int kOffsetFieldNumber = 2;
  inline ::google::protobuf::uint64 offset() const;
  inline void set_offset(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:Mysqlx.Crud.Limit)
 private:
  inline void set_has_row_count();
  inline void clear_has_row_count();
  inline void set_has_offset();
  inline void clear_has_offset();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 row_count_;
  ::google::protobuf::uint64 offset_;
  friend void  protobuf_AddDesc_mysqlx_5fcrud_2eproto();
  friend void protobuf_AssignDesc_mysqlx_5fcrud_2eproto();
  friend void protobuf_ShutdownFile_mysqlx_5fcrud_2eproto();

  void InitAsDefaultInstance();
  static Limit* default_instance_;
};
// -------------------------------------------------------------------

class Order : public ::google::protobuf::Message {
 public:
  Order();
  virtual ~Order();

  Order(const Order& from);

  inline Order& operator=(const Order& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Order& default_instance();

  void Swap(Order* other);

  // implements Message ----------------------------------------------

  Order* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Order& from);
  void MergeFrom(const Order& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Order_Direction Direction;
  static const Direction ASC = Order_Direction_ASC;
  static const Direction DESC = Order_Direction_DESC;
  static inline bool Direction_IsValid(int value) {
    return Order_Direction_IsValid(value);
  }
  static const Direction Direction_MIN =
    Order_Direction_Direction_MIN;
  static const Direction Direction_MAX =
    Order_Direction_Direction_MAX;
  static const int Direction_ARRAYSIZE =
    Order_Direction_Direction_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Direction_descriptor() {
    return Order_Direction_descriptor();
  }
  static inline const ::std::string& Direction_Name(Direction value) {
    return Order_Direction_Name(value);
  }
  static inline bool Direction_Parse(const ::std::string& name,
      Direction* value) {
    return Order_Direction_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .Mysqlx.Expr.Expr expr = 1;
  inline bool has_expr() const;
  inline void clear_expr();
  static const int kExprFieldNumber = 1;
  inline const ::Mysqlx::Expr::Expr& expr() const;
  inline ::Mysqlx::Expr::Expr* mutable_expr();
  inline ::Mysqlx::Expr::Expr* release_expr();
  inline void set_allocated_expr(::Mysqlx::Expr::Expr* expr);

  // optional .Mysqlx.Crud.Order.Direction direction = 2 [default = ASC];
  inline bool has_direction() const;
  inline void clear_direction();
  static const int kDirectionFieldNumber = 2;
  inline ::Mysqlx::Crud::Order_Direction direction() const;
  inline void set_direction(::Mysqlx::Crud::Order_Direction value);

  // @@protoc_insertion_point(class_scope:Mysqlx.Crud.Order)
 private:
  inline void set_has_expr();
  inline void clear_has_expr();
  inline void set_has_direction();
  inline void clear_has_direction();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::Mysqlx::Expr::Expr* expr_;
  int direction_;
  friend void  protobuf_AddDesc_mysqlx_5fcrud_2eproto();
  friend void protobuf_AssignDesc_mysqlx_5fcrud_2eproto();
  friend void protobuf_ShutdownFile_mysqlx_5fcrud_2eproto();

  void InitAsDefaultInstance();
  static Order* default_instance_;
};
// -------------------------------------------------------------------

class UpdateOperation : public ::google::protobuf::Message {
 public:
  UpdateOperation();
  virtual ~UpdateOperation();

  UpdateOperation(const UpdateOperation& from);

  inline UpdateOperation& operator=(const UpdateOperation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdateOperation& default_instance();

  void Swap(UpdateOperation* other);

  // implements Message ----------------------------------------------

  UpdateOperation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UpdateOperation& from);
  void MergeFrom(const UpdateOperation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef UpdateOperation_UpdateType UpdateType;
  static const UpdateType SET = UpdateOperation_UpdateType_SET;
  static const UpdateType ITEM_REMOVE = UpdateOperation_UpdateType_ITEM_REMOVE;
  static const UpdateType ITEM_SET = UpdateOperation_UpdateType_ITEM_SET;
  static const UpdateType ITEM_REPLACE = UpdateOperation_UpdateType_ITEM_REPLACE;
  static const UpdateType ITEM_MERGE = UpdateOperation_UpdateType_ITEM_MERGE;
  static const UpdateType ARRAY_INSERT = UpdateOperation_UpdateType_ARRAY_INSERT;
  static const UpdateType ARRAY_APPEND = UpdateOperation_UpdateType_ARRAY_APPEND;
  static inline bool UpdateType_IsValid(int value) {
    return UpdateOperation_UpdateType_IsValid(value);
  }
  static const UpdateType UpdateType_MIN =
    UpdateOperation_UpdateType_UpdateType_MIN;
  static const UpdateType UpdateType_MAX =
    UpdateOperation_UpdateType_UpdateType_MAX;
  static const int UpdateType_ARRAYSIZE =
    UpdateOperation_UpdateType_UpdateType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  UpdateType_descriptor() {
    return UpdateOperation_UpdateType_descriptor();
  }
  static inline const ::std::string& UpdateType_Name(UpdateType value) {
    return UpdateOperation_UpdateType_Name(value);
  }
  static inline bool UpdateType_Parse(const ::std::string& name,
      UpdateType* value) {
    return UpdateOperation_UpdateType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .Mysqlx.Expr.ColumnIdentifier source = 1;
  inline bool has_source() const;
  inline void clear_source();
  static const int kSourceFieldNumber = 1;
  inline const ::Mysqlx::Expr::ColumnIdentifier& source() const;
  inline ::Mysqlx::Expr::ColumnIdentifier* mutable_source();
  inline ::Mysqlx::Expr::ColumnIdentifier* release_source();
  inline void set_allocated_source(::Mysqlx::Expr::ColumnIdentifier* source);

  // required .Mysqlx.Crud.UpdateOperation.UpdateType operation = 2;
  inline bool has_operation() const;
  inline void clear_operation();
  static const int kOperationFieldNumber = 2;
  inline ::Mysqlx::Crud::UpdateOperation_UpdateType operation() const;
  inline void set_operation(::Mysqlx::Crud::UpdateOperation_UpdateType value);

  // optional .Mysqlx.Expr.Expr value = 3;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 3;
  inline const ::Mysqlx::Expr::Expr& value() const;
  inline ::Mysqlx::Expr::Expr* mutable_value();
  inline ::Mysqlx::Expr::Expr* release_value();
  inline void set_allocated_value(::Mysqlx::Expr::Expr* value);

  // @@protoc_insertion_point(class_scope:Mysqlx.Crud.UpdateOperation)
 private:
  inline void set_has_source();
  inline void clear_has_source();
  inline void set_has_operation();
  inline void clear_has_operation();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::Mysqlx::Expr::ColumnIdentifier* source_;
  ::Mysqlx::Expr::Expr* value_;
  int operation_;
  friend void  protobuf_AddDesc_mysqlx_5fcrud_2eproto();
  friend void protobuf_AssignDesc_mysqlx_5fcrud_2eproto();
  friend void protobuf_ShutdownFile_mysqlx_5fcrud_2eproto();

  void InitAsDefaultInstance();
  static UpdateOperation* default_instance_;
};
// -------------------------------------------------------------------

class Find : public ::google::protobuf::Message {
 public:
  Find();
  virtual ~Find();

  Find(const Find& from);

  inline Find& operator=(const Find& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Find& default_instance();

  void Swap(Find* other);

  // implements Message ----------------------------------------------

  Find* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Find& from);
  void MergeFrom(const Find& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Mysqlx.Crud.Collection collection = 2;
  inline bool has_collection() const;
  inline void clear_collection();
  static const int kCollectionFieldNumber = 2;
  inline const ::Mysqlx::Crud::Collection& collection() const;
  inline ::Mysqlx::Crud::Collection* mutable_collection();
  inline ::Mysqlx::Crud::Collection* release_collection();
  inline void set_allocated_collection(::Mysqlx::Crud::Collection* collection);

  // optional .Mysqlx.Crud.DataModel data_model = 3;
  inline bool has_data_model() const;
  inline void clear_data_model();
  static const int kDataModelFieldNumber = 3;
  inline ::Mysqlx::Crud::DataModel data_model() const;
  inline void set_data_model(::Mysqlx::Crud::DataModel value);

  // repeated .Mysqlx.Crud.Projection projection = 4;
  inline int projection_size() const;
  inline void clear_projection();
  static const int kProjectionFieldNumber = 4;
  inline const ::Mysqlx::Crud::Projection& projection(int index) const;
  inline ::Mysqlx::Crud::Projection* mutable_projection(int index);
  inline ::Mysqlx::Crud::Projection* add_projection();
  inline const ::google::protobuf::RepeatedPtrField< ::Mysqlx::Crud::Projection >&
      projection() const;
  inline ::google::protobuf::RepeatedPtrField< ::Mysqlx::Crud::Projection >*
      mutable_projection();

  // optional .Mysqlx.Expr.Expr criteria = 5;
  inline bool has_criteria() const;
  inline void clear_criteria();
  static const int kCriteriaFieldNumber = 5;
  inline const ::Mysqlx::Expr::Expr& criteria() const;
  inline ::Mysqlx::Expr::Expr* mutable_criteria();
  inline ::Mysqlx::Expr::Expr* release_criteria();
  inline void set_allocated_criteria(::Mysqlx::Expr::Expr* criteria);

  // repeated .Mysqlx.Datatypes.Scalar args = 11;
  inline int args_size() const;
  inline void clear_args();
  static const int kArgsFieldNumber = 11;
  inline const ::Mysqlx::Datatypes::Scalar& args(int index) const;
  inline ::Mysqlx::Datatypes::Scalar* mutable_args(int index);
  inline ::Mysqlx::Datatypes::Scalar* add_args();
  inline const ::google::protobuf::RepeatedPtrField< ::Mysqlx::Datatypes::Scalar >&
      args() const;
  inline ::google::protobuf::RepeatedPtrField< ::Mysqlx::Datatypes::Scalar >*
      mutable_args();

  // optional .Mysqlx.Crud.Limit limit = 6;
  inline bool has_limit() const;
  inline void clear_limit();
  static const int kLimitFieldNumber = 6;
  inline const ::Mysqlx::Crud::Limit& limit() const;
  inline ::Mysqlx::Crud::Limit* mutable_limit();
  inline ::Mysqlx::Crud::Limit* release_limit();
  inline void set_allocated_limit(::Mysqlx::Crud::Limit* limit);

  // repeated .Mysqlx.Crud.Order order = 7;
  inline int order_size() const;
  inline void clear_order();
  static const int kOrderFieldNumber = 7;
  inline const ::Mysqlx::Crud::Order& order(int index) const;
  inline ::Mysqlx::Crud::Order* mutable_order(int index);
  inline ::Mysqlx::Crud::Order* add_order();
  inline const ::google::protobuf::RepeatedPtrField< ::Mysqlx::Crud::Order >&
      order() const;
  inline ::google::protobuf::RepeatedPtrField< ::Mysqlx::Crud::Order >*
      mutable_order();

  // repeated .Mysqlx.Expr.Expr grouping = 8;
  inline int grouping_size() const;
  inline void clear_grouping();
  static const int kGroupingFieldNumber = 8;
  inline const ::Mysqlx::Expr::Expr& grouping(int index) const;
  inline ::Mysqlx::Expr::Expr* mutable_grouping(int index);
  inline ::Mysqlx::Expr::Expr* add_grouping();
  inline const ::google::protobuf::RepeatedPtrField< ::Mysqlx::Expr::Expr >&
      grouping() const;
  inline ::google::protobuf::RepeatedPtrField< ::Mysqlx::Expr::Expr >*
      mutable_grouping();

  // optional .Mysqlx.Expr.Expr grouping_criteria = 9;
  inline bool has_grouping_criteria() const;
  inline void clear_grouping_criteria();
  static const int kGroupingCriteriaFieldNumber = 9;
  inline const ::Mysqlx::Expr::Expr& grouping_criteria() const;
  inline ::Mysqlx::Expr::Expr* mutable_grouping_criteria();
  inline ::Mysqlx::Expr::Expr* release_grouping_criteria();
  inline void set_allocated_grouping_criteria(::Mysqlx::Expr::Expr* grouping_criteria);

  // @@protoc_insertion_point(class_scope:Mysqlx.Crud.Find)
 private:
  inline void set_has_collection();
  inline void clear_has_collection();
  inline void set_has_data_model();
  inline void clear_has_data_model();
  inline void set_has_criteria();
  inline void clear_has_criteria();
  inline void set_has_limit();
  inline void clear_has_limit();
  inline void set_has_grouping_criteria();
  inline void clear_has_grouping_criteria();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::Mysqlx::Crud::Collection* collection_;
  ::google::protobuf::RepeatedPtrField< ::Mysqlx::Crud::Projection > projection_;
  ::Mysqlx::Expr::Expr* criteria_;
  ::google::protobuf::RepeatedPtrField< ::Mysqlx::Datatypes::Scalar > args_;
  ::Mysqlx::Crud::Limit* limit_;
  ::google::protobuf::RepeatedPtrField< ::Mysqlx::Crud::Order > order_;
  ::google::protobuf::RepeatedPtrField< ::Mysqlx::Expr::Expr > grouping_;
  ::Mysqlx::Expr::Expr* grouping_criteria_;
  int data_model_;
  friend void  protobuf_AddDesc_mysqlx_5fcrud_2eproto();
  friend void protobuf_AssignDesc_mysqlx_5fcrud_2eproto();
  friend void protobuf_ShutdownFile_mysqlx_5fcrud_2eproto();

  void InitAsDefaultInstance();
  static Find* default_instance_;
};
// -------------------------------------------------------------------

class Insert_TypedRow : public ::google::protobuf::Message {
 public:
  Insert_TypedRow();
  virtual ~Insert_TypedRow();

  Insert_TypedRow(const Insert_TypedRow& from);

  inline Insert_TypedRow& operator=(const Insert_TypedRow& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Insert_TypedRow& default_instance();

  void Swap(Insert_TypedRow* other);

  // implements Message ----------------------------------------------

  Insert_TypedRow* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Insert_TypedRow& from);
  void MergeFrom(const Insert_TypedRow& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Mysqlx.Expr.Expr field = 1;
  inline int field_size() const;
  inline void clear_field();
  static const int kFieldFieldNumber = 1;
  inline const ::Mysqlx::Expr::Expr& field(int index) const;
  inline ::Mysqlx::Expr::Expr* mutable_field(int index);
  inline ::Mysqlx::Expr::Expr* add_field();
  inline const ::google::protobuf::RepeatedPtrField< ::Mysqlx::Expr::Expr >&
      field() const;
  inline ::google::protobuf::RepeatedPtrField< ::Mysqlx::Expr::Expr >*
      mutable_field();

  // @@protoc_insertion_point(class_scope:Mysqlx.Crud.Insert.TypedRow)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::Mysqlx::Expr::Expr > field_;
  friend void  protobuf_AddDesc_mysqlx_5fcrud_2eproto();
  friend void protobuf_AssignDesc_mysqlx_5fcrud_2eproto();
  friend void protobuf_ShutdownFile_mysqlx_5fcrud_2eproto();

  void InitAsDefaultInstance();
  static Insert_TypedRow* default_instance_;
};
// -------------------------------------------------------------------

class Insert : public ::google::protobuf::Message {
 public:
  Insert();
  virtual ~Insert();

  Insert(const Insert& from);

  inline Insert& operator=(const Insert& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Insert& default_instance();

  void Swap(Insert* other);

  // implements Message ----------------------------------------------

  Insert* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Insert& from);
  void MergeFrom(const Insert& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Insert_TypedRow TypedRow;

  // accessors -------------------------------------------------------

  // required .Mysqlx.Crud.Collection collection = 1;
  inline bool has_collection() const;
  inline void clear_collection();
  static const int kCollectionFieldNumber = 1;
  inline const ::Mysqlx::Crud::Collection& collection() const;
  inline ::Mysqlx::Crud::Collection* mutable_collection();
  inline ::Mysqlx::Crud::Collection* release_collection();
  inline void set_allocated_collection(::Mysqlx::Crud::Collection* collection);

  // optional .Mysqlx.Crud.DataModel data_model = 2;
  inline bool has_data_model() const;
  inline void clear_data_model();
  static const int kDataModelFieldNumber = 2;
  inline ::Mysqlx::Crud::DataModel data_model() const;
  inline void set_data_model(::Mysqlx::Crud::DataModel value);

  // repeated .Mysqlx.Crud.Column projection = 3;
  inline int projection_size() const;
  inline void clear_projection();
  static const int kProjectionFieldNumber = 3;
  inline const ::Mysqlx::Crud::Column& projection(int index) const;
  inline ::Mysqlx::Crud::Column* mutable_projection(int index);
  inline ::Mysqlx::Crud::Column* add_projection();
  inline const ::google::protobuf::RepeatedPtrField< ::Mysqlx::Crud::Column >&
      projection() const;
  inline ::google::protobuf::RepeatedPtrField< ::Mysqlx::Crud::Column >*
      mutable_projection();

  // repeated .Mysqlx.Crud.Insert.TypedRow row = 4;
  inline int row_size() const;
  inline void clear_row();
  static const int kRowFieldNumber = 4;
  inline const ::Mysqlx::Crud::Insert_TypedRow& row(int index) const;
  inline ::Mysqlx::Crud::Insert_TypedRow* mutable_row(int index);
  inline ::Mysqlx::Crud::Insert_TypedRow* add_row();
  inline const ::google::protobuf::RepeatedPtrField< ::Mysqlx::Crud::Insert_TypedRow >&
      row() const;
  inline ::google::protobuf::RepeatedPtrField< ::Mysqlx::Crud::Insert_TypedRow >*
      mutable_row();

  // repeated .Mysqlx.Datatypes.Scalar args = 5;
  inline int args_size() const;
  inline void clear_args();
  static const int kArgsFieldNumber = 5;
  inline const ::Mysqlx::Datatypes::Scalar& args(int index) const;
  inline ::Mysqlx::Datatypes::Scalar* mutable_args(int index);
  inline ::Mysqlx::Datatypes::Scalar* add_args();
  inline const ::google::protobuf::RepeatedPtrField< ::Mysqlx::Datatypes::Scalar >&
      args() const;
  inline ::google::protobuf::RepeatedPtrField< ::Mysqlx::Datatypes::Scalar >*
      mutable_args();

  // @@protoc_insertion_point(class_scope:Mysqlx.Crud.Insert)
 private:
  inline void set_has_collection();
  inline void clear_has_collection();
  inline void set_has_data_model();
  inline void clear_has_data_model();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::Mysqlx::Crud::Collection* collection_;
  ::google::protobuf::RepeatedPtrField< ::Mysqlx::Crud::Column > projection_;
  ::google::protobuf::RepeatedPtrField< ::Mysqlx::Crud::Insert_TypedRow > row_;
  ::google::protobuf::RepeatedPtrField< ::Mysqlx::Datatypes::Scalar > args_;
  int data_model_;
  friend void  protobuf_AddDesc_mysqlx_5fcrud_2eproto();
  friend void protobuf_AssignDesc_mysqlx_5fcrud_2eproto();
  friend void protobuf_ShutdownFile_mysqlx_5fcrud_2eproto();

  void InitAsDefaultInstance();
  static Insert* default_instance_;
};
// -------------------------------------------------------------------

class Update : public ::google::protobuf::Message {
 public:
  Update();
  virtual ~Update();

  Update(const Update& from);

  inline Update& operator=(const Update& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Update& default_instance();

  void Swap(Update* other);

  // implements Message ----------------------------------------------

  Update* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Update& from);
  void MergeFrom(const Update& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Mysqlx.Crud.Collection collection = 2;
  inline bool has_collection() const;
  inline void clear_collection();
  static const int kCollectionFieldNumber = 2;
  inline const ::Mysqlx::Crud::Collection& collection() const;
  inline ::Mysqlx::Crud::Collection* mutable_collection();
  inline ::Mysqlx::Crud::Collection* release_collection();
  inline void set_allocated_collection(::Mysqlx::Crud::Collection* collection);

  // optional .Mysqlx.Crud.DataModel data_model = 3;
  inline bool has_data_model() const;
  inline void clear_data_model();
  static const int kDataModelFieldNumber = 3;
  inline ::Mysqlx::Crud::DataModel data_model() const;
  inline void set_data_model(::Mysqlx::Crud::DataModel value);

  // optional .Mysqlx.Expr.Expr criteria = 4;
  inline bool has_criteria() const;
  inline void clear_criteria();
  static const int kCriteriaFieldNumber = 4;
  inline const ::Mysqlx::Expr::Expr& criteria() const;
  inline ::Mysqlx::Expr::Expr* mutable_criteria();
  inline ::Mysqlx::Expr::Expr* release_criteria();
  inline void set_allocated_criteria(::Mysqlx::Expr::Expr* criteria);

  // repeated .Mysqlx.Datatypes.Scalar args = 8;
  inline int args_size() const;
  inline void clear_args();
  static const int kArgsFieldNumber = 8;
  inline const ::Mysqlx::Datatypes::Scalar& args(int index) const;
  inline ::Mysqlx::Datatypes::Scalar* mutable_args(int index);
  inline ::Mysqlx::Datatypes::Scalar* add_args();
  inline const ::google::protobuf::RepeatedPtrField< ::Mysqlx::Datatypes::Scalar >&
      args() const;
  inline ::google::protobuf::RepeatedPtrField< ::Mysqlx::Datatypes::Scalar >*
      mutable_args();

  // optional .Mysqlx.Crud.Limit limit = 5;
  inline bool has_limit() const;
  inline void clear_limit();
  static const int kLimitFieldNumber = 5;
  inline const ::Mysqlx::Crud::Limit& limit() const;
  inline ::Mysqlx::Crud::Limit* mutable_limit();
  inline ::Mysqlx::Crud::Limit* release_limit();
  inline void set_allocated_limit(::Mysqlx::Crud::Limit* limit);

  // repeated .Mysqlx.Crud.Order order = 6;
  inline int order_size() const;
  inline void clear_order();
  static const int kOrderFieldNumber = 6;
  inline const ::Mysqlx::Crud::Order& order(int index) const;
  inline ::Mysqlx::Crud::Order* mutable_order(int index);
  inline ::Mysqlx::Crud::Order* add_order();
  inline const ::google::protobuf::RepeatedPtrField< ::Mysqlx::Crud::Order >&
      order() const;
  inline ::google::protobuf::RepeatedPtrField< ::Mysqlx::Crud::Order >*
      mutable_order();

  // repeated .Mysqlx.Crud.UpdateOperation operation = 7;
  inline int operation_size() const;
  inline void clear_operation();
  static const int kOperationFieldNumber = 7;
  inline const ::Mysqlx::Crud::UpdateOperation& operation(int index) const;
  inline ::Mysqlx::Crud::UpdateOperation* mutable_operation(int index);
  inline ::Mysqlx::Crud::UpdateOperation* add_operation();
  inline const ::google::protobuf::RepeatedPtrField< ::Mysqlx::Crud::UpdateOperation >&
      operation() const;
  inline ::google::protobuf::RepeatedPtrField< ::Mysqlx::Crud::UpdateOperation >*
      mutable_operation();

  // @@protoc_insertion_point(class_scope:Mysqlx.Crud.Update)
 private:
  inline void set_has_collection();
  inline void clear_has_collection();
  inline void set_has_data_model();
  inline void clear_has_data_model();
  inline void set_has_criteria();
  inline void clear_has_criteria();
  inline void set_has_limit();
  inline void clear_has_limit();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::Mysqlx::Crud::Collection* collection_;
  ::Mysqlx::Expr::Expr* criteria_;
  ::google::protobuf::RepeatedPtrField< ::Mysqlx::Datatypes::Scalar > args_;
  ::Mysqlx::Crud::Limit* limit_;
  ::google::protobuf::RepeatedPtrField< ::Mysqlx::Crud::Order > order_;
  ::google::protobuf::RepeatedPtrField< ::Mysqlx::Crud::UpdateOperation > operation_;
  int data_model_;
  friend void  protobuf_AddDesc_mysqlx_5fcrud_2eproto();
  friend void protobuf_AssignDesc_mysqlx_5fcrud_2eproto();
  friend void protobuf_ShutdownFile_mysqlx_5fcrud_2eproto();

  void InitAsDefaultInstance();
  static Update* default_instance_;
};
// -------------------------------------------------------------------

class Delete : public ::google::protobuf::Message {
 public:
  Delete();
  virtual ~Delete();

  Delete(const Delete& from);

  inline Delete& operator=(const Delete& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Delete& default_instance();

  void Swap(Delete* other);

  // implements Message ----------------------------------------------

  Delete* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Delete& from);
  void MergeFrom(const Delete& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Mysqlx.Crud.Collection collection = 1;
  inline bool has_collection() const;
  inline void clear_collection();
  static const int kCollectionFieldNumber = 1;
  inline const ::Mysqlx::Crud::Collection& collection() const;
  inline ::Mysqlx::Crud::Collection* mutable_collection();
  inline ::Mysqlx::Crud::Collection* release_collection();
  inline void set_allocated_collection(::Mysqlx::Crud::Collection* collection);

  // optional .Mysqlx.Crud.DataModel data_model = 2;
  inline bool has_data_model() const;
  inline void clear_data_model();
  static const int kDataModelFieldNumber = 2;
  inline ::Mysqlx::Crud::DataModel data_model() const;
  inline void set_data_model(::Mysqlx::Crud::DataModel value);

  // optional .Mysqlx.Expr.Expr criteria = 3;
  inline bool has_criteria() const;
  inline void clear_criteria();
  static const int kCriteriaFieldNumber = 3;
  inline const ::Mysqlx::Expr::Expr& criteria() const;
  inline ::Mysqlx::Expr::Expr* mutable_criteria();
  inline ::Mysqlx::Expr::Expr* release_criteria();
  inline void set_allocated_criteria(::Mysqlx::Expr::Expr* criteria);

  // repeated .Mysqlx.Datatypes.Scalar args = 6;
  inline int args_size() const;
  inline void clear_args();
  static const int kArgsFieldNumber = 6;
  inline const ::Mysqlx::Datatypes::Scalar& args(int index) const;
  inline ::Mysqlx::Datatypes::Scalar* mutable_args(int index);
  inline ::Mysqlx::Datatypes::Scalar* add_args();
  inline const ::google::protobuf::RepeatedPtrField< ::Mysqlx::Datatypes::Scalar >&
      args() const;
  inline ::google::protobuf::RepeatedPtrField< ::Mysqlx::Datatypes::Scalar >*
      mutable_args();

  // optional .Mysqlx.Crud.Limit limit = 4;
  inline bool has_limit() const;
  inline void clear_limit();
  static const int kLimitFieldNumber = 4;
  inline const ::Mysqlx::Crud::Limit& limit() const;
  inline ::Mysqlx::Crud::Limit* mutable_limit();
  inline ::Mysqlx::Crud::Limit* release_limit();
  inline void set_allocated_limit(::Mysqlx::Crud::Limit* limit);

  // repeated .Mysqlx.Crud.Order order = 5;
  inline int order_size() const;
  inline void clear_order();
  static const int kOrderFieldNumber = 5;
  inline const ::Mysqlx::Crud::Order& order(int index) const;
  inline ::Mysqlx::Crud::Order* mutable_order(int index);
  inline ::Mysqlx::Crud::Order* add_order();
  inline const ::google::protobuf::RepeatedPtrField< ::Mysqlx::Crud::Order >&
      order() const;
  inline ::google::protobuf::RepeatedPtrField< ::Mysqlx::Crud::Order >*
      mutable_order();

  // @@protoc_insertion_point(class_scope:Mysqlx.Crud.Delete)
 private:
  inline void set_has_collection();
  inline void clear_has_collection();
  inline void set_has_data_model();
  inline void clear_has_data_model();
  inline void set_has_criteria();
  inline void clear_has_criteria();
  inline void set_has_limit();
  inline void clear_has_limit();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::Mysqlx::Crud::Collection* collection_;
  ::Mysqlx::Expr::Expr* criteria_;
  ::google::protobuf::RepeatedPtrField< ::Mysqlx::Datatypes::Scalar > args_;
  ::Mysqlx::Crud::Limit* limit_;
  ::google::protobuf::RepeatedPtrField< ::Mysqlx::Crud::Order > order_;
  int data_model_;
  friend void  protobuf_AddDesc_mysqlx_5fcrud_2eproto();
  friend void protobuf_AssignDesc_mysqlx_5fcrud_2eproto();
  friend void protobuf_ShutdownFile_mysqlx_5fcrud_2eproto();

  void InitAsDefaultInstance();
  static Delete* default_instance_;
};
// ===================================================================


// ===================================================================

// Column

// optional string name = 1;
inline bool Column::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Column::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Column::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Column::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Column::name() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Column.name)
  return *name_;
}
inline void Column::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:Mysqlx.Crud.Column.name)
}
inline void Column::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:Mysqlx.Crud.Column.name)
}
inline void Column::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Mysqlx.Crud.Column.name)
}
inline ::std::string* Column::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Column.name)
  return name_;
}
inline ::std::string* Column::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Column::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Crud.Column.name)
}

// optional string alias = 2;
inline bool Column::has_alias() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Column::set_has_alias() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Column::clear_has_alias() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Column::clear_alias() {
  if (alias_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    alias_->clear();
  }
  clear_has_alias();
}
inline const ::std::string& Column::alias() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Column.alias)
  return *alias_;
}
inline void Column::set_alias(const ::std::string& value) {
  set_has_alias();
  if (alias_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    alias_ = new ::std::string;
  }
  alias_->assign(value);
  // @@protoc_insertion_point(field_set:Mysqlx.Crud.Column.alias)
}
inline void Column::set_alias(const char* value) {
  set_has_alias();
  if (alias_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    alias_ = new ::std::string;
  }
  alias_->assign(value);
  // @@protoc_insertion_point(field_set_char:Mysqlx.Crud.Column.alias)
}
inline void Column::set_alias(const char* value, size_t size) {
  set_has_alias();
  if (alias_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    alias_ = new ::std::string;
  }
  alias_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Mysqlx.Crud.Column.alias)
}
inline ::std::string* Column::mutable_alias() {
  set_has_alias();
  if (alias_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    alias_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Column.alias)
  return alias_;
}
inline ::std::string* Column::release_alias() {
  clear_has_alias();
  if (alias_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = alias_;
    alias_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Column::set_allocated_alias(::std::string* alias) {
  if (alias_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete alias_;
  }
  if (alias) {
    set_has_alias();
    alias_ = alias;
  } else {
    clear_has_alias();
    alias_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Crud.Column.alias)
}

// repeated .Mysqlx.Expr.DocumentPathItem document_path = 3;
inline int Column::document_path_size() const {
  return document_path_.size();
}
inline void Column::clear_document_path() {
  document_path_.Clear();
}
inline const ::Mysqlx::Expr::DocumentPathItem& Column::document_path(int index) const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Column.document_path)
  return document_path_.Get(index);
}
inline ::Mysqlx::Expr::DocumentPathItem* Column::mutable_document_path(int index) {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Column.document_path)
  return document_path_.Mutable(index);
}
inline ::Mysqlx::Expr::DocumentPathItem* Column::add_document_path() {
  // @@protoc_insertion_point(field_add:Mysqlx.Crud.Column.document_path)
  return document_path_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Mysqlx::Expr::DocumentPathItem >&
Column::document_path() const {
  // @@protoc_insertion_point(field_list:Mysqlx.Crud.Column.document_path)
  return document_path_;
}
inline ::google::protobuf::RepeatedPtrField< ::Mysqlx::Expr::DocumentPathItem >*
Column::mutable_document_path() {
  // @@protoc_insertion_point(field_mutable_list:Mysqlx.Crud.Column.document_path)
  return &document_path_;
}

// -------------------------------------------------------------------

// Projection

// required .Mysqlx.Expr.Expr source = 1;
inline bool Projection::has_source() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Projection::set_has_source() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Projection::clear_has_source() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Projection::clear_source() {
  if (source_ != NULL) source_->::Mysqlx::Expr::Expr::Clear();
  clear_has_source();
}
inline const ::Mysqlx::Expr::Expr& Projection::source() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Projection.source)
  return source_ != NULL ? *source_ : *default_instance_->source_;
}
inline ::Mysqlx::Expr::Expr* Projection::mutable_source() {
  set_has_source();
  if (source_ == NULL) source_ = new ::Mysqlx::Expr::Expr;
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Projection.source)
  return source_;
}
inline ::Mysqlx::Expr::Expr* Projection::release_source() {
  clear_has_source();
  ::Mysqlx::Expr::Expr* temp = source_;
  source_ = NULL;
  return temp;
}
inline void Projection::set_allocated_source(::Mysqlx::Expr::Expr* source) {
  delete source_;
  source_ = source;
  if (source) {
    set_has_source();
  } else {
    clear_has_source();
  }
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Crud.Projection.source)
}

// optional string alias = 2;
inline bool Projection::has_alias() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Projection::set_has_alias() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Projection::clear_has_alias() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Projection::clear_alias() {
  if (alias_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    alias_->clear();
  }
  clear_has_alias();
}
inline const ::std::string& Projection::alias() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Projection.alias)
  return *alias_;
}
inline void Projection::set_alias(const ::std::string& value) {
  set_has_alias();
  if (alias_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    alias_ = new ::std::string;
  }
  alias_->assign(value);
  // @@protoc_insertion_point(field_set:Mysqlx.Crud.Projection.alias)
}
inline void Projection::set_alias(const char* value) {
  set_has_alias();
  if (alias_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    alias_ = new ::std::string;
  }
  alias_->assign(value);
  // @@protoc_insertion_point(field_set_char:Mysqlx.Crud.Projection.alias)
}
inline void Projection::set_alias(const char* value, size_t size) {
  set_has_alias();
  if (alias_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    alias_ = new ::std::string;
  }
  alias_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Mysqlx.Crud.Projection.alias)
}
inline ::std::string* Projection::mutable_alias() {
  set_has_alias();
  if (alias_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    alias_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Projection.alias)
  return alias_;
}
inline ::std::string* Projection::release_alias() {
  clear_has_alias();
  if (alias_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = alias_;
    alias_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Projection::set_allocated_alias(::std::string* alias) {
  if (alias_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete alias_;
  }
  if (alias) {
    set_has_alias();
    alias_ = alias;
  } else {
    clear_has_alias();
    alias_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Crud.Projection.alias)
}

// -------------------------------------------------------------------

// Collection

// required string name = 1;
inline bool Collection::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Collection::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Collection::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Collection::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Collection::name() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Collection.name)
  return *name_;
}
inline void Collection::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:Mysqlx.Crud.Collection.name)
}
inline void Collection::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:Mysqlx.Crud.Collection.name)
}
inline void Collection::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Mysqlx.Crud.Collection.name)
}
inline ::std::string* Collection::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Collection.name)
  return name_;
}
inline ::std::string* Collection::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Collection::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Crud.Collection.name)
}

// optional string schema = 2;
inline bool Collection::has_schema() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Collection::set_has_schema() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Collection::clear_has_schema() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Collection::clear_schema() {
  if (schema_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    schema_->clear();
  }
  clear_has_schema();
}
inline const ::std::string& Collection::schema() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Collection.schema)
  return *schema_;
}
inline void Collection::set_schema(const ::std::string& value) {
  set_has_schema();
  if (schema_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    schema_ = new ::std::string;
  }
  schema_->assign(value);
  // @@protoc_insertion_point(field_set:Mysqlx.Crud.Collection.schema)
}
inline void Collection::set_schema(const char* value) {
  set_has_schema();
  if (schema_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    schema_ = new ::std::string;
  }
  schema_->assign(value);
  // @@protoc_insertion_point(field_set_char:Mysqlx.Crud.Collection.schema)
}
inline void Collection::set_schema(const char* value, size_t size) {
  set_has_schema();
  if (schema_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    schema_ = new ::std::string;
  }
  schema_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Mysqlx.Crud.Collection.schema)
}
inline ::std::string* Collection::mutable_schema() {
  set_has_schema();
  if (schema_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    schema_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Collection.schema)
  return schema_;
}
inline ::std::string* Collection::release_schema() {
  clear_has_schema();
  if (schema_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = schema_;
    schema_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Collection::set_allocated_schema(::std::string* schema) {
  if (schema_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete schema_;
  }
  if (schema) {
    set_has_schema();
    schema_ = schema;
  } else {
    clear_has_schema();
    schema_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Crud.Collection.schema)
}

// -------------------------------------------------------------------

// Limit

// required uint64 row_count = 1;
inline bool Limit::has_row_count() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Limit::set_has_row_count() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Limit::clear_has_row_count() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Limit::clear_row_count() {
  row_count_ = GOOGLE_ULONGLONG(0);
  clear_has_row_count();
}
inline ::google::protobuf::uint64 Limit::row_count() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Limit.row_count)
  return row_count_;
}
inline void Limit::set_row_count(::google::protobuf::uint64 value) {
  set_has_row_count();
  row_count_ = value;
  // @@protoc_insertion_point(field_set:Mysqlx.Crud.Limit.row_count)
}

// optional uint64 offset = 2;
inline bool Limit::has_offset() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Limit::set_has_offset() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Limit::clear_has_offset() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Limit::clear_offset() {
  offset_ = GOOGLE_ULONGLONG(0);
  clear_has_offset();
}
inline ::google::protobuf::uint64 Limit::offset() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Limit.offset)
  return offset_;
}
inline void Limit::set_offset(::google::protobuf::uint64 value) {
  set_has_offset();
  offset_ = value;
  // @@protoc_insertion_point(field_set:Mysqlx.Crud.Limit.offset)
}

// -------------------------------------------------------------------

// Order

// required .Mysqlx.Expr.Expr expr = 1;
inline bool Order::has_expr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Order::set_has_expr() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Order::clear_has_expr() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Order::clear_expr() {
  if (expr_ != NULL) expr_->::Mysqlx::Expr::Expr::Clear();
  clear_has_expr();
}
inline const ::Mysqlx::Expr::Expr& Order::expr() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Order.expr)
  return expr_ != NULL ? *expr_ : *default_instance_->expr_;
}
inline ::Mysqlx::Expr::Expr* Order::mutable_expr() {
  set_has_expr();
  if (expr_ == NULL) expr_ = new ::Mysqlx::Expr::Expr;
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Order.expr)
  return expr_;
}
inline ::Mysqlx::Expr::Expr* Order::release_expr() {
  clear_has_expr();
  ::Mysqlx::Expr::Expr* temp = expr_;
  expr_ = NULL;
  return temp;
}
inline void Order::set_allocated_expr(::Mysqlx::Expr::Expr* expr) {
  delete expr_;
  expr_ = expr;
  if (expr) {
    set_has_expr();
  } else {
    clear_has_expr();
  }
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Crud.Order.expr)
}

// optional .Mysqlx.Crud.Order.Direction direction = 2 [default = ASC];
inline bool Order::has_direction() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Order::set_has_direction() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Order::clear_has_direction() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Order::clear_direction() {
  direction_ = 1;
  clear_has_direction();
}
inline ::Mysqlx::Crud::Order_Direction Order::direction() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Order.direction)
  return static_cast< ::Mysqlx::Crud::Order_Direction >(direction_);
}
inline void Order::set_direction(::Mysqlx::Crud::Order_Direction value) {
  assert(::Mysqlx::Crud::Order_Direction_IsValid(value));
  set_has_direction();
  direction_ = value;
  // @@protoc_insertion_point(field_set:Mysqlx.Crud.Order.direction)
}

// -------------------------------------------------------------------

// UpdateOperation

// required .Mysqlx.Expr.ColumnIdentifier source = 1;
inline bool UpdateOperation::has_source() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpdateOperation::set_has_source() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpdateOperation::clear_has_source() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpdateOperation::clear_source() {
  if (source_ != NULL) source_->::Mysqlx::Expr::ColumnIdentifier::Clear();
  clear_has_source();
}
inline const ::Mysqlx::Expr::ColumnIdentifier& UpdateOperation::source() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.UpdateOperation.source)
  return source_ != NULL ? *source_ : *default_instance_->source_;
}
inline ::Mysqlx::Expr::ColumnIdentifier* UpdateOperation::mutable_source() {
  set_has_source();
  if (source_ == NULL) source_ = new ::Mysqlx::Expr::ColumnIdentifier;
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.UpdateOperation.source)
  return source_;
}
inline ::Mysqlx::Expr::ColumnIdentifier* UpdateOperation::release_source() {
  clear_has_source();
  ::Mysqlx::Expr::ColumnIdentifier* temp = source_;
  source_ = NULL;
  return temp;
}
inline void UpdateOperation::set_allocated_source(::Mysqlx::Expr::ColumnIdentifier* source) {
  delete source_;
  source_ = source;
  if (source) {
    set_has_source();
  } else {
    clear_has_source();
  }
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Crud.UpdateOperation.source)
}

// required .Mysqlx.Crud.UpdateOperation.UpdateType operation = 2;
inline bool UpdateOperation::has_operation() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UpdateOperation::set_has_operation() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UpdateOperation::clear_has_operation() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UpdateOperation::clear_operation() {
  operation_ = 1;
  clear_has_operation();
}
inline ::Mysqlx::Crud::UpdateOperation_UpdateType UpdateOperation::operation() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.UpdateOperation.operation)
  return static_cast< ::Mysqlx::Crud::UpdateOperation_UpdateType >(operation_);
}
inline void UpdateOperation::set_operation(::Mysqlx::Crud::UpdateOperation_UpdateType value) {
  assert(::Mysqlx::Crud::UpdateOperation_UpdateType_IsValid(value));
  set_has_operation();
  operation_ = value;
  // @@protoc_insertion_point(field_set:Mysqlx.Crud.UpdateOperation.operation)
}

// optional .Mysqlx.Expr.Expr value = 3;
inline bool UpdateOperation::has_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UpdateOperation::set_has_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UpdateOperation::clear_has_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UpdateOperation::clear_value() {
  if (value_ != NULL) value_->::Mysqlx::Expr::Expr::Clear();
  clear_has_value();
}
inline const ::Mysqlx::Expr::Expr& UpdateOperation::value() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.UpdateOperation.value)
  return value_ != NULL ? *value_ : *default_instance_->value_;
}
inline ::Mysqlx::Expr::Expr* UpdateOperation::mutable_value() {
  set_has_value();
  if (value_ == NULL) value_ = new ::Mysqlx::Expr::Expr;
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.UpdateOperation.value)
  return value_;
}
inline ::Mysqlx::Expr::Expr* UpdateOperation::release_value() {
  clear_has_value();
  ::Mysqlx::Expr::Expr* temp = value_;
  value_ = NULL;
  return temp;
}
inline void UpdateOperation::set_allocated_value(::Mysqlx::Expr::Expr* value) {
  delete value_;
  value_ = value;
  if (value) {
    set_has_value();
  } else {
    clear_has_value();
  }
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Crud.UpdateOperation.value)
}

// -------------------------------------------------------------------

// Find

// required .Mysqlx.Crud.Collection collection = 2;
inline bool Find::has_collection() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Find::set_has_collection() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Find::clear_has_collection() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Find::clear_collection() {
  if (collection_ != NULL) collection_->::Mysqlx::Crud::Collection::Clear();
  clear_has_collection();
}
inline const ::Mysqlx::Crud::Collection& Find::collection() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Find.collection)
  return collection_ != NULL ? *collection_ : *default_instance_->collection_;
}
inline ::Mysqlx::Crud::Collection* Find::mutable_collection() {
  set_has_collection();
  if (collection_ == NULL) collection_ = new ::Mysqlx::Crud::Collection;
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Find.collection)
  return collection_;
}
inline ::Mysqlx::Crud::Collection* Find::release_collection() {
  clear_has_collection();
  ::Mysqlx::Crud::Collection* temp = collection_;
  collection_ = NULL;
  return temp;
}
inline void Find::set_allocated_collection(::Mysqlx::Crud::Collection* collection) {
  delete collection_;
  collection_ = collection;
  if (collection) {
    set_has_collection();
  } else {
    clear_has_collection();
  }
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Crud.Find.collection)
}

// optional .Mysqlx.Crud.DataModel data_model = 3;
inline bool Find::has_data_model() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Find::set_has_data_model() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Find::clear_has_data_model() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Find::clear_data_model() {
  data_model_ = 1;
  clear_has_data_model();
}
inline ::Mysqlx::Crud::DataModel Find::data_model() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Find.data_model)
  return static_cast< ::Mysqlx::Crud::DataModel >(data_model_);
}
inline void Find::set_data_model(::Mysqlx::Crud::DataModel value) {
  assert(::Mysqlx::Crud::DataModel_IsValid(value));
  set_has_data_model();
  data_model_ = value;
  // @@protoc_insertion_point(field_set:Mysqlx.Crud.Find.data_model)
}

// repeated .Mysqlx.Crud.Projection projection = 4;
inline int Find::projection_size() const {
  return projection_.size();
}
inline void Find::clear_projection() {
  projection_.Clear();
}
inline const ::Mysqlx::Crud::Projection& Find::projection(int index) const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Find.projection)
  return projection_.Get(index);
}
inline ::Mysqlx::Crud::Projection* Find::mutable_projection(int index) {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Find.projection)
  return projection_.Mutable(index);
}
inline ::Mysqlx::Crud::Projection* Find::add_projection() {
  // @@protoc_insertion_point(field_add:Mysqlx.Crud.Find.projection)
  return projection_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Mysqlx::Crud::Projection >&
Find::projection() const {
  // @@protoc_insertion_point(field_list:Mysqlx.Crud.Find.projection)
  return projection_;
}
inline ::google::protobuf::RepeatedPtrField< ::Mysqlx::Crud::Projection >*
Find::mutable_projection() {
  // @@protoc_insertion_point(field_mutable_list:Mysqlx.Crud.Find.projection)
  return &projection_;
}

// optional .Mysqlx.Expr.Expr criteria = 5;
inline bool Find::has_criteria() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Find::set_has_criteria() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Find::clear_has_criteria() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Find::clear_criteria() {
  if (criteria_ != NULL) criteria_->::Mysqlx::Expr::Expr::Clear();
  clear_has_criteria();
}
inline const ::Mysqlx::Expr::Expr& Find::criteria() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Find.criteria)
  return criteria_ != NULL ? *criteria_ : *default_instance_->criteria_;
}
inline ::Mysqlx::Expr::Expr* Find::mutable_criteria() {
  set_has_criteria();
  if (criteria_ == NULL) criteria_ = new ::Mysqlx::Expr::Expr;
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Find.criteria)
  return criteria_;
}
inline ::Mysqlx::Expr::Expr* Find::release_criteria() {
  clear_has_criteria();
  ::Mysqlx::Expr::Expr* temp = criteria_;
  criteria_ = NULL;
  return temp;
}
inline void Find::set_allocated_criteria(::Mysqlx::Expr::Expr* criteria) {
  delete criteria_;
  criteria_ = criteria;
  if (criteria) {
    set_has_criteria();
  } else {
    clear_has_criteria();
  }
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Crud.Find.criteria)
}

// repeated .Mysqlx.Datatypes.Scalar args = 11;
inline int Find::args_size() const {
  return args_.size();
}
inline void Find::clear_args() {
  args_.Clear();
}
inline const ::Mysqlx::Datatypes::Scalar& Find::args(int index) const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Find.args)
  return args_.Get(index);
}
inline ::Mysqlx::Datatypes::Scalar* Find::mutable_args(int index) {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Find.args)
  return args_.Mutable(index);
}
inline ::Mysqlx::Datatypes::Scalar* Find::add_args() {
  // @@protoc_insertion_point(field_add:Mysqlx.Crud.Find.args)
  return args_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Mysqlx::Datatypes::Scalar >&
Find::args() const {
  // @@protoc_insertion_point(field_list:Mysqlx.Crud.Find.args)
  return args_;
}
inline ::google::protobuf::RepeatedPtrField< ::Mysqlx::Datatypes::Scalar >*
Find::mutable_args() {
  // @@protoc_insertion_point(field_mutable_list:Mysqlx.Crud.Find.args)
  return &args_;
}

// optional .Mysqlx.Crud.Limit limit = 6;
inline bool Find::has_limit() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Find::set_has_limit() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Find::clear_has_limit() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Find::clear_limit() {
  if (limit_ != NULL) limit_->::Mysqlx::Crud::Limit::Clear();
  clear_has_limit();
}
inline const ::Mysqlx::Crud::Limit& Find::limit() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Find.limit)
  return limit_ != NULL ? *limit_ : *default_instance_->limit_;
}
inline ::Mysqlx::Crud::Limit* Find::mutable_limit() {
  set_has_limit();
  if (limit_ == NULL) limit_ = new ::Mysqlx::Crud::Limit;
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Find.limit)
  return limit_;
}
inline ::Mysqlx::Crud::Limit* Find::release_limit() {
  clear_has_limit();
  ::Mysqlx::Crud::Limit* temp = limit_;
  limit_ = NULL;
  return temp;
}
inline void Find::set_allocated_limit(::Mysqlx::Crud::Limit* limit) {
  delete limit_;
  limit_ = limit;
  if (limit) {
    set_has_limit();
  } else {
    clear_has_limit();
  }
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Crud.Find.limit)
}

// repeated .Mysqlx.Crud.Order order = 7;
inline int Find::order_size() const {
  return order_.size();
}
inline void Find::clear_order() {
  order_.Clear();
}
inline const ::Mysqlx::Crud::Order& Find::order(int index) const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Find.order)
  return order_.Get(index);
}
inline ::Mysqlx::Crud::Order* Find::mutable_order(int index) {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Find.order)
  return order_.Mutable(index);
}
inline ::Mysqlx::Crud::Order* Find::add_order() {
  // @@protoc_insertion_point(field_add:Mysqlx.Crud.Find.order)
  return order_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Mysqlx::Crud::Order >&
Find::order() const {
  // @@protoc_insertion_point(field_list:Mysqlx.Crud.Find.order)
  return order_;
}
inline ::google::protobuf::RepeatedPtrField< ::Mysqlx::Crud::Order >*
Find::mutable_order() {
  // @@protoc_insertion_point(field_mutable_list:Mysqlx.Crud.Find.order)
  return &order_;
}

// repeated .Mysqlx.Expr.Expr grouping = 8;
inline int Find::grouping_size() const {
  return grouping_.size();
}
inline void Find::clear_grouping() {
  grouping_.Clear();
}
inline const ::Mysqlx::Expr::Expr& Find::grouping(int index) const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Find.grouping)
  return grouping_.Get(index);
}
inline ::Mysqlx::Expr::Expr* Find::mutable_grouping(int index) {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Find.grouping)
  return grouping_.Mutable(index);
}
inline ::Mysqlx::Expr::Expr* Find::add_grouping() {
  // @@protoc_insertion_point(field_add:Mysqlx.Crud.Find.grouping)
  return grouping_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Mysqlx::Expr::Expr >&
Find::grouping() const {
  // @@protoc_insertion_point(field_list:Mysqlx.Crud.Find.grouping)
  return grouping_;
}
inline ::google::protobuf::RepeatedPtrField< ::Mysqlx::Expr::Expr >*
Find::mutable_grouping() {
  // @@protoc_insertion_point(field_mutable_list:Mysqlx.Crud.Find.grouping)
  return &grouping_;
}

// optional .Mysqlx.Expr.Expr grouping_criteria = 9;
inline bool Find::has_grouping_criteria() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Find::set_has_grouping_criteria() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Find::clear_has_grouping_criteria() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Find::clear_grouping_criteria() {
  if (grouping_criteria_ != NULL) grouping_criteria_->::Mysqlx::Expr::Expr::Clear();
  clear_has_grouping_criteria();
}
inline const ::Mysqlx::Expr::Expr& Find::grouping_criteria() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Find.grouping_criteria)
  return grouping_criteria_ != NULL ? *grouping_criteria_ : *default_instance_->grouping_criteria_;
}
inline ::Mysqlx::Expr::Expr* Find::mutable_grouping_criteria() {
  set_has_grouping_criteria();
  if (grouping_criteria_ == NULL) grouping_criteria_ = new ::Mysqlx::Expr::Expr;
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Find.grouping_criteria)
  return grouping_criteria_;
}
inline ::Mysqlx::Expr::Expr* Find::release_grouping_criteria() {
  clear_has_grouping_criteria();
  ::Mysqlx::Expr::Expr* temp = grouping_criteria_;
  grouping_criteria_ = NULL;
  return temp;
}
inline void Find::set_allocated_grouping_criteria(::Mysqlx::Expr::Expr* grouping_criteria) {
  delete grouping_criteria_;
  grouping_criteria_ = grouping_criteria;
  if (grouping_criteria) {
    set_has_grouping_criteria();
  } else {
    clear_has_grouping_criteria();
  }
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Crud.Find.grouping_criteria)
}

// -------------------------------------------------------------------

// Insert_TypedRow

// repeated .Mysqlx.Expr.Expr field = 1;
inline int Insert_TypedRow::field_size() const {
  return field_.size();
}
inline void Insert_TypedRow::clear_field() {
  field_.Clear();
}
inline const ::Mysqlx::Expr::Expr& Insert_TypedRow::field(int index) const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Insert.TypedRow.field)
  return field_.Get(index);
}
inline ::Mysqlx::Expr::Expr* Insert_TypedRow::mutable_field(int index) {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Insert.TypedRow.field)
  return field_.Mutable(index);
}
inline ::Mysqlx::Expr::Expr* Insert_TypedRow::add_field() {
  // @@protoc_insertion_point(field_add:Mysqlx.Crud.Insert.TypedRow.field)
  return field_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Mysqlx::Expr::Expr >&
Insert_TypedRow::field() const {
  // @@protoc_insertion_point(field_list:Mysqlx.Crud.Insert.TypedRow.field)
  return field_;
}
inline ::google::protobuf::RepeatedPtrField< ::Mysqlx::Expr::Expr >*
Insert_TypedRow::mutable_field() {
  // @@protoc_insertion_point(field_mutable_list:Mysqlx.Crud.Insert.TypedRow.field)
  return &field_;
}

// -------------------------------------------------------------------

// Insert

// required .Mysqlx.Crud.Collection collection = 1;
inline bool Insert::has_collection() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Insert::set_has_collection() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Insert::clear_has_collection() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Insert::clear_collection() {
  if (collection_ != NULL) collection_->::Mysqlx::Crud::Collection::Clear();
  clear_has_collection();
}
inline const ::Mysqlx::Crud::Collection& Insert::collection() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Insert.collection)
  return collection_ != NULL ? *collection_ : *default_instance_->collection_;
}
inline ::Mysqlx::Crud::Collection* Insert::mutable_collection() {
  set_has_collection();
  if (collection_ == NULL) collection_ = new ::Mysqlx::Crud::Collection;
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Insert.collection)
  return collection_;
}
inline ::Mysqlx::Crud::Collection* Insert::release_collection() {
  clear_has_collection();
  ::Mysqlx::Crud::Collection* temp = collection_;
  collection_ = NULL;
  return temp;
}
inline void Insert::set_allocated_collection(::Mysqlx::Crud::Collection* collection) {
  delete collection_;
  collection_ = collection;
  if (collection) {
    set_has_collection();
  } else {
    clear_has_collection();
  }
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Crud.Insert.collection)
}

// optional .Mysqlx.Crud.DataModel data_model = 2;
inline bool Insert::has_data_model() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Insert::set_has_data_model() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Insert::clear_has_data_model() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Insert::clear_data_model() {
  data_model_ = 1;
  clear_has_data_model();
}
inline ::Mysqlx::Crud::DataModel Insert::data_model() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Insert.data_model)
  return static_cast< ::Mysqlx::Crud::DataModel >(data_model_);
}
inline void Insert::set_data_model(::Mysqlx::Crud::DataModel value) {
  assert(::Mysqlx::Crud::DataModel_IsValid(value));
  set_has_data_model();
  data_model_ = value;
  // @@protoc_insertion_point(field_set:Mysqlx.Crud.Insert.data_model)
}

// repeated .Mysqlx.Crud.Column projection = 3;
inline int Insert::projection_size() const {
  return projection_.size();
}
inline void Insert::clear_projection() {
  projection_.Clear();
}
inline const ::Mysqlx::Crud::Column& Insert::projection(int index) const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Insert.projection)
  return projection_.Get(index);
}
inline ::Mysqlx::Crud::Column* Insert::mutable_projection(int index) {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Insert.projection)
  return projection_.Mutable(index);
}
inline ::Mysqlx::Crud::Column* Insert::add_projection() {
  // @@protoc_insertion_point(field_add:Mysqlx.Crud.Insert.projection)
  return projection_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Mysqlx::Crud::Column >&
Insert::projection() const {
  // @@protoc_insertion_point(field_list:Mysqlx.Crud.Insert.projection)
  return projection_;
}
inline ::google::protobuf::RepeatedPtrField< ::Mysqlx::Crud::Column >*
Insert::mutable_projection() {
  // @@protoc_insertion_point(field_mutable_list:Mysqlx.Crud.Insert.projection)
  return &projection_;
}

// repeated .Mysqlx.Crud.Insert.TypedRow row = 4;
inline int Insert::row_size() const {
  return row_.size();
}
inline void Insert::clear_row() {
  row_.Clear();
}
inline const ::Mysqlx::Crud::Insert_TypedRow& Insert::row(int index) const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Insert.row)
  return row_.Get(index);
}
inline ::Mysqlx::Crud::Insert_TypedRow* Insert::mutable_row(int index) {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Insert.row)
  return row_.Mutable(index);
}
inline ::Mysqlx::Crud::Insert_TypedRow* Insert::add_row() {
  // @@protoc_insertion_point(field_add:Mysqlx.Crud.Insert.row)
  return row_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Mysqlx::Crud::Insert_TypedRow >&
Insert::row() const {
  // @@protoc_insertion_point(field_list:Mysqlx.Crud.Insert.row)
  return row_;
}
inline ::google::protobuf::RepeatedPtrField< ::Mysqlx::Crud::Insert_TypedRow >*
Insert::mutable_row() {
  // @@protoc_insertion_point(field_mutable_list:Mysqlx.Crud.Insert.row)
  return &row_;
}

// repeated .Mysqlx.Datatypes.Scalar args = 5;
inline int Insert::args_size() const {
  return args_.size();
}
inline void Insert::clear_args() {
  args_.Clear();
}
inline const ::Mysqlx::Datatypes::Scalar& Insert::args(int index) const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Insert.args)
  return args_.Get(index);
}
inline ::Mysqlx::Datatypes::Scalar* Insert::mutable_args(int index) {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Insert.args)
  return args_.Mutable(index);
}
inline ::Mysqlx::Datatypes::Scalar* Insert::add_args() {
  // @@protoc_insertion_point(field_add:Mysqlx.Crud.Insert.args)
  return args_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Mysqlx::Datatypes::Scalar >&
Insert::args() const {
  // @@protoc_insertion_point(field_list:Mysqlx.Crud.Insert.args)
  return args_;
}
inline ::google::protobuf::RepeatedPtrField< ::Mysqlx::Datatypes::Scalar >*
Insert::mutable_args() {
  // @@protoc_insertion_point(field_mutable_list:Mysqlx.Crud.Insert.args)
  return &args_;
}

// -------------------------------------------------------------------

// Update

// required .Mysqlx.Crud.Collection collection = 2;
inline bool Update::has_collection() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Update::set_has_collection() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Update::clear_has_collection() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Update::clear_collection() {
  if (collection_ != NULL) collection_->::Mysqlx::Crud::Collection::Clear();
  clear_has_collection();
}
inline const ::Mysqlx::Crud::Collection& Update::collection() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Update.collection)
  return collection_ != NULL ? *collection_ : *default_instance_->collection_;
}
inline ::Mysqlx::Crud::Collection* Update::mutable_collection() {
  set_has_collection();
  if (collection_ == NULL) collection_ = new ::Mysqlx::Crud::Collection;
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Update.collection)
  return collection_;
}
inline ::Mysqlx::Crud::Collection* Update::release_collection() {
  clear_has_collection();
  ::Mysqlx::Crud::Collection* temp = collection_;
  collection_ = NULL;
  return temp;
}
inline void Update::set_allocated_collection(::Mysqlx::Crud::Collection* collection) {
  delete collection_;
  collection_ = collection;
  if (collection) {
    set_has_collection();
  } else {
    clear_has_collection();
  }
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Crud.Update.collection)
}

// optional .Mysqlx.Crud.DataModel data_model = 3;
inline bool Update::has_data_model() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Update::set_has_data_model() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Update::clear_has_data_model() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Update::clear_data_model() {
  data_model_ = 1;
  clear_has_data_model();
}
inline ::Mysqlx::Crud::DataModel Update::data_model() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Update.data_model)
  return static_cast< ::Mysqlx::Crud::DataModel >(data_model_);
}
inline void Update::set_data_model(::Mysqlx::Crud::DataModel value) {
  assert(::Mysqlx::Crud::DataModel_IsValid(value));
  set_has_data_model();
  data_model_ = value;
  // @@protoc_insertion_point(field_set:Mysqlx.Crud.Update.data_model)
}

// optional .Mysqlx.Expr.Expr criteria = 4;
inline bool Update::has_criteria() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Update::set_has_criteria() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Update::clear_has_criteria() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Update::clear_criteria() {
  if (criteria_ != NULL) criteria_->::Mysqlx::Expr::Expr::Clear();
  clear_has_criteria();
}
inline const ::Mysqlx::Expr::Expr& Update::criteria() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Update.criteria)
  return criteria_ != NULL ? *criteria_ : *default_instance_->criteria_;
}
inline ::Mysqlx::Expr::Expr* Update::mutable_criteria() {
  set_has_criteria();
  if (criteria_ == NULL) criteria_ = new ::Mysqlx::Expr::Expr;
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Update.criteria)
  return criteria_;
}
inline ::Mysqlx::Expr::Expr* Update::release_criteria() {
  clear_has_criteria();
  ::Mysqlx::Expr::Expr* temp = criteria_;
  criteria_ = NULL;
  return temp;
}
inline void Update::set_allocated_criteria(::Mysqlx::Expr::Expr* criteria) {
  delete criteria_;
  criteria_ = criteria;
  if (criteria) {
    set_has_criteria();
  } else {
    clear_has_criteria();
  }
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Crud.Update.criteria)
}

// repeated .Mysqlx.Datatypes.Scalar args = 8;
inline int Update::args_size() const {
  return args_.size();
}
inline void Update::clear_args() {
  args_.Clear();
}
inline const ::Mysqlx::Datatypes::Scalar& Update::args(int index) const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Update.args)
  return args_.Get(index);
}
inline ::Mysqlx::Datatypes::Scalar* Update::mutable_args(int index) {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Update.args)
  return args_.Mutable(index);
}
inline ::Mysqlx::Datatypes::Scalar* Update::add_args() {
  // @@protoc_insertion_point(field_add:Mysqlx.Crud.Update.args)
  return args_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Mysqlx::Datatypes::Scalar >&
Update::args() const {
  // @@protoc_insertion_point(field_list:Mysqlx.Crud.Update.args)
  return args_;
}
inline ::google::protobuf::RepeatedPtrField< ::Mysqlx::Datatypes::Scalar >*
Update::mutable_args() {
  // @@protoc_insertion_point(field_mutable_list:Mysqlx.Crud.Update.args)
  return &args_;
}

// optional .Mysqlx.Crud.Limit limit = 5;
inline bool Update::has_limit() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Update::set_has_limit() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Update::clear_has_limit() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Update::clear_limit() {
  if (limit_ != NULL) limit_->::Mysqlx::Crud::Limit::Clear();
  clear_has_limit();
}
inline const ::Mysqlx::Crud::Limit& Update::limit() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Update.limit)
  return limit_ != NULL ? *limit_ : *default_instance_->limit_;
}
inline ::Mysqlx::Crud::Limit* Update::mutable_limit() {
  set_has_limit();
  if (limit_ == NULL) limit_ = new ::Mysqlx::Crud::Limit;
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Update.limit)
  return limit_;
}
inline ::Mysqlx::Crud::Limit* Update::release_limit() {
  clear_has_limit();
  ::Mysqlx::Crud::Limit* temp = limit_;
  limit_ = NULL;
  return temp;
}
inline void Update::set_allocated_limit(::Mysqlx::Crud::Limit* limit) {
  delete limit_;
  limit_ = limit;
  if (limit) {
    set_has_limit();
  } else {
    clear_has_limit();
  }
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Crud.Update.limit)
}

// repeated .Mysqlx.Crud.Order order = 6;
inline int Update::order_size() const {
  return order_.size();
}
inline void Update::clear_order() {
  order_.Clear();
}
inline const ::Mysqlx::Crud::Order& Update::order(int index) const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Update.order)
  return order_.Get(index);
}
inline ::Mysqlx::Crud::Order* Update::mutable_order(int index) {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Update.order)
  return order_.Mutable(index);
}
inline ::Mysqlx::Crud::Order* Update::add_order() {
  // @@protoc_insertion_point(field_add:Mysqlx.Crud.Update.order)
  return order_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Mysqlx::Crud::Order >&
Update::order() const {
  // @@protoc_insertion_point(field_list:Mysqlx.Crud.Update.order)
  return order_;
}
inline ::google::protobuf::RepeatedPtrField< ::Mysqlx::Crud::Order >*
Update::mutable_order() {
  // @@protoc_insertion_point(field_mutable_list:Mysqlx.Crud.Update.order)
  return &order_;
}

// repeated .Mysqlx.Crud.UpdateOperation operation = 7;
inline int Update::operation_size() const {
  return operation_.size();
}
inline void Update::clear_operation() {
  operation_.Clear();
}
inline const ::Mysqlx::Crud::UpdateOperation& Update::operation(int index) const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Update.operation)
  return operation_.Get(index);
}
inline ::Mysqlx::Crud::UpdateOperation* Update::mutable_operation(int index) {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Update.operation)
  return operation_.Mutable(index);
}
inline ::Mysqlx::Crud::UpdateOperation* Update::add_operation() {
  // @@protoc_insertion_point(field_add:Mysqlx.Crud.Update.operation)
  return operation_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Mysqlx::Crud::UpdateOperation >&
Update::operation() const {
  // @@protoc_insertion_point(field_list:Mysqlx.Crud.Update.operation)
  return operation_;
}
inline ::google::protobuf::RepeatedPtrField< ::Mysqlx::Crud::UpdateOperation >*
Update::mutable_operation() {
  // @@protoc_insertion_point(field_mutable_list:Mysqlx.Crud.Update.operation)
  return &operation_;
}

// -------------------------------------------------------------------

// Delete

// required .Mysqlx.Crud.Collection collection = 1;
inline bool Delete::has_collection() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Delete::set_has_collection() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Delete::clear_has_collection() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Delete::clear_collection() {
  if (collection_ != NULL) collection_->::Mysqlx::Crud::Collection::Clear();
  clear_has_collection();
}
inline const ::Mysqlx::Crud::Collection& Delete::collection() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Delete.collection)
  return collection_ != NULL ? *collection_ : *default_instance_->collection_;
}
inline ::Mysqlx::Crud::Collection* Delete::mutable_collection() {
  set_has_collection();
  if (collection_ == NULL) collection_ = new ::Mysqlx::Crud::Collection;
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Delete.collection)
  return collection_;
}
inline ::Mysqlx::Crud::Collection* Delete::release_collection() {
  clear_has_collection();
  ::Mysqlx::Crud::Collection* temp = collection_;
  collection_ = NULL;
  return temp;
}
inline void Delete::set_allocated_collection(::Mysqlx::Crud::Collection* collection) {
  delete collection_;
  collection_ = collection;
  if (collection) {
    set_has_collection();
  } else {
    clear_has_collection();
  }
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Crud.Delete.collection)
}

// optional .Mysqlx.Crud.DataModel data_model = 2;
inline bool Delete::has_data_model() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Delete::set_has_data_model() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Delete::clear_has_data_model() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Delete::clear_data_model() {
  data_model_ = 1;
  clear_has_data_model();
}
inline ::Mysqlx::Crud::DataModel Delete::data_model() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Delete.data_model)
  return static_cast< ::Mysqlx::Crud::DataModel >(data_model_);
}
inline void Delete::set_data_model(::Mysqlx::Crud::DataModel value) {
  assert(::Mysqlx::Crud::DataModel_IsValid(value));
  set_has_data_model();
  data_model_ = value;
  // @@protoc_insertion_point(field_set:Mysqlx.Crud.Delete.data_model)
}

// optional .Mysqlx.Expr.Expr criteria = 3;
inline bool Delete::has_criteria() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Delete::set_has_criteria() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Delete::clear_has_criteria() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Delete::clear_criteria() {
  if (criteria_ != NULL) criteria_->::Mysqlx::Expr::Expr::Clear();
  clear_has_criteria();
}
inline const ::Mysqlx::Expr::Expr& Delete::criteria() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Delete.criteria)
  return criteria_ != NULL ? *criteria_ : *default_instance_->criteria_;
}
inline ::Mysqlx::Expr::Expr* Delete::mutable_criteria() {
  set_has_criteria();
  if (criteria_ == NULL) criteria_ = new ::Mysqlx::Expr::Expr;
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Delete.criteria)
  return criteria_;
}
inline ::Mysqlx::Expr::Expr* Delete::release_criteria() {
  clear_has_criteria();
  ::Mysqlx::Expr::Expr* temp = criteria_;
  criteria_ = NULL;
  return temp;
}
inline void Delete::set_allocated_criteria(::Mysqlx::Expr::Expr* criteria) {
  delete criteria_;
  criteria_ = criteria;
  if (criteria) {
    set_has_criteria();
  } else {
    clear_has_criteria();
  }
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Crud.Delete.criteria)
}

// repeated .Mysqlx.Datatypes.Scalar args = 6;
inline int Delete::args_size() const {
  return args_.size();
}
inline void Delete::clear_args() {
  args_.Clear();
}
inline const ::Mysqlx::Datatypes::Scalar& Delete::args(int index) const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Delete.args)
  return args_.Get(index);
}
inline ::Mysqlx::Datatypes::Scalar* Delete::mutable_args(int index) {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Delete.args)
  return args_.Mutable(index);
}
inline ::Mysqlx::Datatypes::Scalar* Delete::add_args() {
  // @@protoc_insertion_point(field_add:Mysqlx.Crud.Delete.args)
  return args_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Mysqlx::Datatypes::Scalar >&
Delete::args() const {
  // @@protoc_insertion_point(field_list:Mysqlx.Crud.Delete.args)
  return args_;
}
inline ::google::protobuf::RepeatedPtrField< ::Mysqlx::Datatypes::Scalar >*
Delete::mutable_args() {
  // @@protoc_insertion_point(field_mutable_list:Mysqlx.Crud.Delete.args)
  return &args_;
}

// optional .Mysqlx.Crud.Limit limit = 4;
inline bool Delete::has_limit() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Delete::set_has_limit() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Delete::clear_has_limit() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Delete::clear_limit() {
  if (limit_ != NULL) limit_->::Mysqlx::Crud::Limit::Clear();
  clear_has_limit();
}
inline const ::Mysqlx::Crud::Limit& Delete::limit() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Delete.limit)
  return limit_ != NULL ? *limit_ : *default_instance_->limit_;
}
inline ::Mysqlx::Crud::Limit* Delete::mutable_limit() {
  set_has_limit();
  if (limit_ == NULL) limit_ = new ::Mysqlx::Crud::Limit;
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Delete.limit)
  return limit_;
}
inline ::Mysqlx::Crud::Limit* Delete::release_limit() {
  clear_has_limit();
  ::Mysqlx::Crud::Limit* temp = limit_;
  limit_ = NULL;
  return temp;
}
inline void Delete::set_allocated_limit(::Mysqlx::Crud::Limit* limit) {
  delete limit_;
  limit_ = limit;
  if (limit) {
    set_has_limit();
  } else {
    clear_has_limit();
  }
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Crud.Delete.limit)
}

// repeated .Mysqlx.Crud.Order order = 5;
inline int Delete::order_size() const {
  return order_.size();
}
inline void Delete::clear_order() {
  order_.Clear();
}
inline const ::Mysqlx::Crud::Order& Delete::order(int index) const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Delete.order)
  return order_.Get(index);
}
inline ::Mysqlx::Crud::Order* Delete::mutable_order(int index) {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Delete.order)
  return order_.Mutable(index);
}
inline ::Mysqlx::Crud::Order* Delete::add_order() {
  // @@protoc_insertion_point(field_add:Mysqlx.Crud.Delete.order)
  return order_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Mysqlx::Crud::Order >&
Delete::order() const {
  // @@protoc_insertion_point(field_list:Mysqlx.Crud.Delete.order)
  return order_;
}
inline ::google::protobuf::RepeatedPtrField< ::Mysqlx::Crud::Order >*
Delete::mutable_order() {
  // @@protoc_insertion_point(field_mutable_list:Mysqlx.Crud.Delete.order)
  return &order_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace Crud
}  // namespace Mysqlx

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::Mysqlx::Crud::Order_Direction> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Mysqlx::Crud::Order_Direction>() {
  return ::Mysqlx::Crud::Order_Direction_descriptor();
}
template <> struct is_proto_enum< ::Mysqlx::Crud::UpdateOperation_UpdateType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Mysqlx::Crud::UpdateOperation_UpdateType>() {
  return ::Mysqlx::Crud::UpdateOperation_UpdateType_descriptor();
}
template <> struct is_proto_enum< ::Mysqlx::Crud::DataModel> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Mysqlx::Crud::DataModel>() {
  return ::Mysqlx::Crud::DataModel_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_mysqlx_5fcrud_2eproto__INCLUDED

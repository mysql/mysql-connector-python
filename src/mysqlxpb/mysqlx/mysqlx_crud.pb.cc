/*
 * MySQL Connector/Python - MySQL driver written in Python.
 * Copyright (c) 2017, Oracle and/or its affiliates. All rights reserved.
 *
 * MySQL Connector/Python is licensed under the terms of the GPLv2
 * <http://www.gnu.org/licenses/old-licenses/gpl-2.0.html>, like most
 * MySQL Connectors. There are special exceptions to the terms and
 * conditions of the GPLv2 as it is applied to this software, see the
 * FOSS License Exception
 * <http://www.mysql.com/about/legal/licensing/foss-exception.html>.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
 */

// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mysqlx_crud.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "mysqlx_crud.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace Mysqlx {
namespace Crud {

namespace {

const ::google::protobuf::Descriptor* Column_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Column_reflection_ = NULL;
const ::google::protobuf::Descriptor* Projection_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Projection_reflection_ = NULL;
const ::google::protobuf::Descriptor* Collection_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Collection_reflection_ = NULL;
const ::google::protobuf::Descriptor* Limit_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Limit_reflection_ = NULL;
const ::google::protobuf::Descriptor* Order_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Order_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* Order_Direction_descriptor_ = NULL;
const ::google::protobuf::Descriptor* UpdateOperation_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  UpdateOperation_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* UpdateOperation_UpdateType_descriptor_ = NULL;
const ::google::protobuf::Descriptor* Find_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Find_reflection_ = NULL;
const ::google::protobuf::Descriptor* Insert_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Insert_reflection_ = NULL;
const ::google::protobuf::Descriptor* Insert_TypedRow_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Insert_TypedRow_reflection_ = NULL;
const ::google::protobuf::Descriptor* Update_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Update_reflection_ = NULL;
const ::google::protobuf::Descriptor* Delete_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Delete_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* DataModel_descriptor_ = NULL;

}  // namespace


void protobuf_AssignDesc_mysqlx_5fcrud_2eproto() {
  protobuf_AddDesc_mysqlx_5fcrud_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "mysqlx_crud.proto");
  GOOGLE_CHECK(file != NULL);
  Column_descriptor_ = file->message_type(0);
  static const int Column_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Column, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Column, alias_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Column, document_path_),
  };
  Column_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Column_descriptor_,
      Column::default_instance_,
      Column_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Column, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Column, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Column));
  Projection_descriptor_ = file->message_type(1);
  static const int Projection_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Projection, source_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Projection, alias_),
  };
  Projection_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Projection_descriptor_,
      Projection::default_instance_,
      Projection_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Projection, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Projection, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Projection));
  Collection_descriptor_ = file->message_type(2);
  static const int Collection_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Collection, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Collection, schema_),
  };
  Collection_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Collection_descriptor_,
      Collection::default_instance_,
      Collection_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Collection, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Collection, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Collection));
  Limit_descriptor_ = file->message_type(3);
  static const int Limit_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Limit, row_count_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Limit, offset_),
  };
  Limit_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Limit_descriptor_,
      Limit::default_instance_,
      Limit_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Limit, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Limit, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Limit));
  Order_descriptor_ = file->message_type(4);
  static const int Order_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Order, expr_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Order, direction_),
  };
  Order_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Order_descriptor_,
      Order::default_instance_,
      Order_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Order, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Order, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Order));
  Order_Direction_descriptor_ = Order_descriptor_->enum_type(0);
  UpdateOperation_descriptor_ = file->message_type(5);
  static const int UpdateOperation_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UpdateOperation, source_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UpdateOperation, operation_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UpdateOperation, value_),
  };
  UpdateOperation_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      UpdateOperation_descriptor_,
      UpdateOperation::default_instance_,
      UpdateOperation_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UpdateOperation, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UpdateOperation, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(UpdateOperation));
  UpdateOperation_UpdateType_descriptor_ = UpdateOperation_descriptor_->enum_type(0);
  Find_descriptor_ = file->message_type(6);
  static const int Find_offsets_[9] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Find, collection_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Find, data_model_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Find, projection_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Find, criteria_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Find, args_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Find, limit_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Find, order_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Find, grouping_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Find, grouping_criteria_),
  };
  Find_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Find_descriptor_,
      Find::default_instance_,
      Find_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Find, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Find, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Find));
  Insert_descriptor_ = file->message_type(7);
  static const int Insert_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Insert, collection_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Insert, data_model_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Insert, projection_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Insert, row_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Insert, args_),
  };
  Insert_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Insert_descriptor_,
      Insert::default_instance_,
      Insert_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Insert, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Insert, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Insert));
  Insert_TypedRow_descriptor_ = Insert_descriptor_->nested_type(0);
  static const int Insert_TypedRow_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Insert_TypedRow, field_),
  };
  Insert_TypedRow_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Insert_TypedRow_descriptor_,
      Insert_TypedRow::default_instance_,
      Insert_TypedRow_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Insert_TypedRow, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Insert_TypedRow, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Insert_TypedRow));
  Update_descriptor_ = file->message_type(8);
  static const int Update_offsets_[7] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Update, collection_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Update, data_model_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Update, criteria_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Update, args_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Update, limit_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Update, order_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Update, operation_),
  };
  Update_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Update_descriptor_,
      Update::default_instance_,
      Update_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Update, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Update, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Update));
  Delete_descriptor_ = file->message_type(9);
  static const int Delete_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Delete, collection_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Delete, data_model_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Delete, criteria_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Delete, args_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Delete, limit_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Delete, order_),
  };
  Delete_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Delete_descriptor_,
      Delete::default_instance_,
      Delete_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Delete, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Delete, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Delete));
  DataModel_descriptor_ = file->enum_type(0);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_mysqlx_5fcrud_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Column_descriptor_, &Column::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Projection_descriptor_, &Projection::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Collection_descriptor_, &Collection::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Limit_descriptor_, &Limit::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Order_descriptor_, &Order::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    UpdateOperation_descriptor_, &UpdateOperation::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Find_descriptor_, &Find::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Insert_descriptor_, &Insert::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Insert_TypedRow_descriptor_, &Insert_TypedRow::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Update_descriptor_, &Update::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Delete_descriptor_, &Delete::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_mysqlx_5fcrud_2eproto() {
  delete Column::default_instance_;
  delete Column_reflection_;
  delete Projection::default_instance_;
  delete Projection_reflection_;
  delete Collection::default_instance_;
  delete Collection_reflection_;
  delete Limit::default_instance_;
  delete Limit_reflection_;
  delete Order::default_instance_;
  delete Order_reflection_;
  delete UpdateOperation::default_instance_;
  delete UpdateOperation_reflection_;
  delete Find::default_instance_;
  delete Find_reflection_;
  delete Insert::default_instance_;
  delete Insert_reflection_;
  delete Insert_TypedRow::default_instance_;
  delete Insert_TypedRow_reflection_;
  delete Update::default_instance_;
  delete Update_reflection_;
  delete Delete::default_instance_;
  delete Delete_reflection_;
}

void protobuf_AddDesc_mysqlx_5fcrud_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::Mysqlx::Expr::protobuf_AddDesc_mysqlx_5fexpr_2eproto();
  ::Mysqlx::Datatypes::protobuf_AddDesc_mysqlx_5fdatatypes_2eproto();
  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\021mysqlx_crud.proto\022\013Mysqlx.Crud\032\021mysqlx"
    "_expr.proto\032\026mysqlx_datatypes.proto\"[\n\006C"
    "olumn\022\014\n\004name\030\001 \001(\t\022\r\n\005alias\030\002 \001(\t\0224\n\rdo"
    "cument_path\030\003 \003(\0132\035.Mysqlx.Expr.Document"
    "PathItem\">\n\nProjection\022!\n\006source\030\001 \002(\0132\021"
    ".Mysqlx.Expr.Expr\022\r\n\005alias\030\002 \001(\t\"*\n\nColl"
    "ection\022\014\n\004name\030\001 \002(\t\022\016\n\006schema\030\002 \001(\t\"*\n\005"
    "Limit\022\021\n\trow_count\030\001 \002(\004\022\016\n\006offset\030\002 \001(\004"
    "\"~\n\005Order\022\037\n\004expr\030\001 \002(\0132\021.Mysqlx.Expr.Ex"
    "pr\0224\n\tdirection\030\002 \001(\0162\034.Mysqlx.Crud.Orde"
    "r.Direction:\003ASC\"\036\n\tDirection\022\007\n\003ASC\020\001\022\010"
    "\n\004DESC\020\002\"\232\002\n\017UpdateOperation\022-\n\006source\030\001"
    " \002(\0132\035.Mysqlx.Expr.ColumnIdentifier\022:\n\to"
    "peration\030\002 \002(\0162\'.Mysqlx.Crud.UpdateOpera"
    "tion.UpdateType\022 \n\005value\030\003 \001(\0132\021.Mysqlx."
    "Expr.Expr\"z\n\nUpdateType\022\007\n\003SET\020\001\022\017\n\013ITEM"
    "_REMOVE\020\002\022\014\n\010ITEM_SET\020\003\022\020\n\014ITEM_REPLACE\020"
    "\004\022\016\n\nITEM_MERGE\020\005\022\020\n\014ARRAY_INSERT\020\006\022\020\n\014A"
    "RRAY_APPEND\020\007\"\362\002\n\004Find\022+\n\ncollection\030\002 \002"
    "(\0132\027.Mysqlx.Crud.Collection\022*\n\ndata_mode"
    "l\030\003 \001(\0162\026.Mysqlx.Crud.DataModel\022+\n\nproje"
    "ction\030\004 \003(\0132\027.Mysqlx.Crud.Projection\022#\n\010"
    "criteria\030\005 \001(\0132\021.Mysqlx.Expr.Expr\022&\n\004arg"
    "s\030\013 \003(\0132\030.Mysqlx.Datatypes.Scalar\022!\n\005lim"
    "it\030\006 \001(\0132\022.Mysqlx.Crud.Limit\022!\n\005order\030\007 "
    "\003(\0132\022.Mysqlx.Crud.Order\022#\n\010grouping\030\010 \003("
    "\0132\021.Mysqlx.Expr.Expr\022,\n\021grouping_criteri"
    "a\030\t \001(\0132\021.Mysqlx.Expr.Expr\"\213\002\n\006Insert\022+\n"
    "\ncollection\030\001 \002(\0132\027.Mysqlx.Crud.Collecti"
    "on\022*\n\ndata_model\030\002 \001(\0162\026.Mysqlx.Crud.Dat"
    "aModel\022\'\n\nprojection\030\003 \003(\0132\023.Mysqlx.Crud"
    ".Column\022)\n\003row\030\004 \003(\0132\034.Mysqlx.Crud.Inser"
    "t.TypedRow\022&\n\004args\030\005 \003(\0132\030.Mysqlx.Dataty"
    "pes.Scalar\032,\n\010TypedRow\022 \n\005field\030\001 \003(\0132\021."
    "Mysqlx.Expr.Expr\"\245\002\n\006Update\022+\n\ncollectio"
    "n\030\002 \002(\0132\027.Mysqlx.Crud.Collection\022*\n\ndata"
    "_model\030\003 \001(\0162\026.Mysqlx.Crud.DataModel\022#\n\010"
    "criteria\030\004 \001(\0132\021.Mysqlx.Expr.Expr\022&\n\004arg"
    "s\030\010 \003(\0132\030.Mysqlx.Datatypes.Scalar\022!\n\005lim"
    "it\030\005 \001(\0132\022.Mysqlx.Crud.Limit\022!\n\005order\030\006 "
    "\003(\0132\022.Mysqlx.Crud.Order\022/\n\toperation\030\007 \003"
    "(\0132\034.Mysqlx.Crud.UpdateOperation\"\364\001\n\006Del"
    "ete\022+\n\ncollection\030\001 \002(\0132\027.Mysqlx.Crud.Co"
    "llection\022*\n\ndata_model\030\002 \001(\0162\026.Mysqlx.Cr"
    "ud.DataModel\022#\n\010criteria\030\003 \001(\0132\021.Mysqlx."
    "Expr.Expr\022&\n\004args\030\006 \003(\0132\030.Mysqlx.Datatyp"
    "es.Scalar\022!\n\005limit\030\004 \001(\0132\022.Mysqlx.Crud.L"
    "imit\022!\n\005order\030\005 \003(\0132\022.Mysqlx.Crud.Order*"
    "$\n\tDataModel\022\014\n\010DOCUMENT\020\001\022\t\n\005TABLE\020\002B\036\n"
    "\034com.mysql.cj.mysqlx.protobuf", 1989);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "mysqlx_crud.proto", &protobuf_RegisterTypes);
  Column::default_instance_ = new Column();
  Projection::default_instance_ = new Projection();
  Collection::default_instance_ = new Collection();
  Limit::default_instance_ = new Limit();
  Order::default_instance_ = new Order();
  UpdateOperation::default_instance_ = new UpdateOperation();
  Find::default_instance_ = new Find();
  Insert::default_instance_ = new Insert();
  Insert_TypedRow::default_instance_ = new Insert_TypedRow();
  Update::default_instance_ = new Update();
  Delete::default_instance_ = new Delete();
  Column::default_instance_->InitAsDefaultInstance();
  Projection::default_instance_->InitAsDefaultInstance();
  Collection::default_instance_->InitAsDefaultInstance();
  Limit::default_instance_->InitAsDefaultInstance();
  Order::default_instance_->InitAsDefaultInstance();
  UpdateOperation::default_instance_->InitAsDefaultInstance();
  Find::default_instance_->InitAsDefaultInstance();
  Insert::default_instance_->InitAsDefaultInstance();
  Insert_TypedRow::default_instance_->InitAsDefaultInstance();
  Update::default_instance_->InitAsDefaultInstance();
  Delete::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_mysqlx_5fcrud_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_mysqlx_5fcrud_2eproto {
  StaticDescriptorInitializer_mysqlx_5fcrud_2eproto() {
    protobuf_AddDesc_mysqlx_5fcrud_2eproto();
  }
} static_descriptor_initializer_mysqlx_5fcrud_2eproto_;
const ::google::protobuf::EnumDescriptor* DataModel_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return DataModel_descriptor_;
}
bool DataModel_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}


// ===================================================================

#ifndef _MSC_VER
const int Column::kNameFieldNumber;
const int Column::kAliasFieldNumber;
const int Column::kDocumentPathFieldNumber;
#endif  // !_MSC_VER

Column::Column()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Mysqlx.Crud.Column)
}

void Column::InitAsDefaultInstance() {
}

Column::Column(const Column& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:Mysqlx.Crud.Column)
}

void Column::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  alias_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Column::~Column() {
  // @@protoc_insertion_point(destructor:Mysqlx.Crud.Column)
  SharedDtor();
}

void Column::SharedDtor() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (alias_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete alias_;
  }
  if (this != default_instance_) {
  }
}

void Column::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Column::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Column_descriptor_;
}

const Column& Column::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mysqlx_5fcrud_2eproto();
  return *default_instance_;
}

Column* Column::default_instance_ = NULL;

Column* Column::New() const {
  return new Column;
}

void Column::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        name_->clear();
      }
    }
    if (has_alias()) {
      if (alias_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        alias_->clear();
      }
    }
  }
  document_path_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Column::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Mysqlx.Crud.Column)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_alias;
        break;
      }

      // optional string alias = 2;
      case 2: {
        if (tag == 18) {
         parse_alias:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_alias()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->alias().data(), this->alias().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "alias");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_document_path;
        break;
      }

      // repeated .Mysqlx.Expr.DocumentPathItem document_path = 3;
      case 3: {
        if (tag == 26) {
         parse_document_path:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_document_path()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_document_path;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Mysqlx.Crud.Column)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Mysqlx.Crud.Column)
  return false;
#undef DO_
}

void Column::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Mysqlx.Crud.Column)
  // optional string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->name(), output);
  }

  // optional string alias = 2;
  if (has_alias()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->alias().data(), this->alias().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "alias");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->alias(), output);
  }

  // repeated .Mysqlx.Expr.DocumentPathItem document_path = 3;
  for (int i = 0; i < this->document_path_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->document_path(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Mysqlx.Crud.Column)
}

::google::protobuf::uint8* Column::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:Mysqlx.Crud.Column)
  // optional string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }

  // optional string alias = 2;
  if (has_alias()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->alias().data(), this->alias().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "alias");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->alias(), target);
  }

  // repeated .Mysqlx.Expr.DocumentPathItem document_path = 3;
  for (int i = 0; i < this->document_path_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->document_path(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Mysqlx.Crud.Column)
  return target;
}

int Column::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional string alias = 2;
    if (has_alias()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->alias());
    }

  }
  // repeated .Mysqlx.Expr.DocumentPathItem document_path = 3;
  total_size += 1 * this->document_path_size();
  for (int i = 0; i < this->document_path_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->document_path(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Column::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Column* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Column*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Column::MergeFrom(const Column& from) {
  GOOGLE_CHECK_NE(&from, this);
  document_path_.MergeFrom(from.document_path_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_alias()) {
      set_alias(from.alias());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Column::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Column::CopyFrom(const Column& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Column::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->document_path())) return false;
  return true;
}

void Column::Swap(Column* other) {
  if (other != this) {
    std::swap(name_, other->name_);
    std::swap(alias_, other->alias_);
    document_path_.Swap(&other->document_path_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Column::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Column_descriptor_;
  metadata.reflection = Column_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Projection::kSourceFieldNumber;
const int Projection::kAliasFieldNumber;
#endif  // !_MSC_VER

Projection::Projection()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Mysqlx.Crud.Projection)
}

void Projection::InitAsDefaultInstance() {
  source_ = const_cast< ::Mysqlx::Expr::Expr*>(&::Mysqlx::Expr::Expr::default_instance());
}

Projection::Projection(const Projection& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:Mysqlx.Crud.Projection)
}

void Projection::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  source_ = NULL;
  alias_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Projection::~Projection() {
  // @@protoc_insertion_point(destructor:Mysqlx.Crud.Projection)
  SharedDtor();
}

void Projection::SharedDtor() {
  if (alias_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete alias_;
  }
  if (this != default_instance_) {
    delete source_;
  }
}

void Projection::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Projection::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Projection_descriptor_;
}

const Projection& Projection::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mysqlx_5fcrud_2eproto();
  return *default_instance_;
}

Projection* Projection::default_instance_ = NULL;

Projection* Projection::New() const {
  return new Projection;
}

void Projection::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_source()) {
      if (source_ != NULL) source_->::Mysqlx::Expr::Expr::Clear();
    }
    if (has_alias()) {
      if (alias_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        alias_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Projection::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Mysqlx.Crud.Projection)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .Mysqlx.Expr.Expr source = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_source()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_alias;
        break;
      }

      // optional string alias = 2;
      case 2: {
        if (tag == 18) {
         parse_alias:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_alias()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->alias().data(), this->alias().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "alias");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Mysqlx.Crud.Projection)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Mysqlx.Crud.Projection)
  return false;
#undef DO_
}

void Projection::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Mysqlx.Crud.Projection)
  // required .Mysqlx.Expr.Expr source = 1;
  if (has_source()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->source(), output);
  }

  // optional string alias = 2;
  if (has_alias()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->alias().data(), this->alias().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "alias");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->alias(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Mysqlx.Crud.Projection)
}

::google::protobuf::uint8* Projection::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:Mysqlx.Crud.Projection)
  // required .Mysqlx.Expr.Expr source = 1;
  if (has_source()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->source(), target);
  }

  // optional string alias = 2;
  if (has_alias()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->alias().data(), this->alias().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "alias");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->alias(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Mysqlx.Crud.Projection)
  return target;
}

int Projection::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .Mysqlx.Expr.Expr source = 1;
    if (has_source()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->source());
    }

    // optional string alias = 2;
    if (has_alias()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->alias());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Projection::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Projection* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Projection*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Projection::MergeFrom(const Projection& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_source()) {
      mutable_source()->::Mysqlx::Expr::Expr::MergeFrom(from.source());
    }
    if (from.has_alias()) {
      set_alias(from.alias());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Projection::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Projection::CopyFrom(const Projection& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Projection::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_source()) {
    if (!this->source().IsInitialized()) return false;
  }
  return true;
}

void Projection::Swap(Projection* other) {
  if (other != this) {
    std::swap(source_, other->source_);
    std::swap(alias_, other->alias_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Projection::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Projection_descriptor_;
  metadata.reflection = Projection_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Collection::kNameFieldNumber;
const int Collection::kSchemaFieldNumber;
#endif  // !_MSC_VER

Collection::Collection()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Mysqlx.Crud.Collection)
}

void Collection::InitAsDefaultInstance() {
}

Collection::Collection(const Collection& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:Mysqlx.Crud.Collection)
}

void Collection::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  schema_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Collection::~Collection() {
  // @@protoc_insertion_point(destructor:Mysqlx.Crud.Collection)
  SharedDtor();
}

void Collection::SharedDtor() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (schema_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete schema_;
  }
  if (this != default_instance_) {
  }
}

void Collection::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Collection::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Collection_descriptor_;
}

const Collection& Collection::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mysqlx_5fcrud_2eproto();
  return *default_instance_;
}

Collection* Collection::default_instance_ = NULL;

Collection* Collection::New() const {
  return new Collection;
}

void Collection::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        name_->clear();
      }
    }
    if (has_schema()) {
      if (schema_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        schema_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Collection::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Mysqlx.Crud.Collection)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_schema;
        break;
      }

      // optional string schema = 2;
      case 2: {
        if (tag == 18) {
         parse_schema:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_schema()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->schema().data(), this->schema().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "schema");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Mysqlx.Crud.Collection)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Mysqlx.Crud.Collection)
  return false;
#undef DO_
}

void Collection::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Mysqlx.Crud.Collection)
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->name(), output);
  }

  // optional string schema = 2;
  if (has_schema()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->schema().data(), this->schema().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "schema");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->schema(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Mysqlx.Crud.Collection)
}

::google::protobuf::uint8* Collection::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:Mysqlx.Crud.Collection)
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }

  // optional string schema = 2;
  if (has_schema()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->schema().data(), this->schema().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "schema");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->schema(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Mysqlx.Crud.Collection)
  return target;
}

int Collection::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional string schema = 2;
    if (has_schema()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->schema());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Collection::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Collection* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Collection*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Collection::MergeFrom(const Collection& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_schema()) {
      set_schema(from.schema());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Collection::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Collection::CopyFrom(const Collection& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Collection::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void Collection::Swap(Collection* other) {
  if (other != this) {
    std::swap(name_, other->name_);
    std::swap(schema_, other->schema_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Collection::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Collection_descriptor_;
  metadata.reflection = Collection_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Limit::kRowCountFieldNumber;
const int Limit::kOffsetFieldNumber;
#endif  // !_MSC_VER

Limit::Limit()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Mysqlx.Crud.Limit)
}

void Limit::InitAsDefaultInstance() {
}

Limit::Limit(const Limit& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:Mysqlx.Crud.Limit)
}

void Limit::SharedCtor() {
  _cached_size_ = 0;
  row_count_ = GOOGLE_ULONGLONG(0);
  offset_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Limit::~Limit() {
  // @@protoc_insertion_point(destructor:Mysqlx.Crud.Limit)
  SharedDtor();
}

void Limit::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Limit::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Limit::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Limit_descriptor_;
}

const Limit& Limit::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mysqlx_5fcrud_2eproto();
  return *default_instance_;
}

Limit* Limit::default_instance_ = NULL;

Limit* Limit::New() const {
  return new Limit;
}

void Limit::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<Limit*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(row_count_, offset_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Limit::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Mysqlx.Crud.Limit)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 row_count = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &row_count_)));
          set_has_row_count();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_offset;
        break;
      }

      // optional uint64 offset = 2;
      case 2: {
        if (tag == 16) {
         parse_offset:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &offset_)));
          set_has_offset();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Mysqlx.Crud.Limit)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Mysqlx.Crud.Limit)
  return false;
#undef DO_
}

void Limit::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Mysqlx.Crud.Limit)
  // required uint64 row_count = 1;
  if (has_row_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->row_count(), output);
  }

  // optional uint64 offset = 2;
  if (has_offset()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->offset(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Mysqlx.Crud.Limit)
}

::google::protobuf::uint8* Limit::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:Mysqlx.Crud.Limit)
  // required uint64 row_count = 1;
  if (has_row_count()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(1, this->row_count(), target);
  }

  // optional uint64 offset = 2;
  if (has_offset()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(2, this->offset(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Mysqlx.Crud.Limit)
  return target;
}

int Limit::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 row_count = 1;
    if (has_row_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->row_count());
    }

    // optional uint64 offset = 2;
    if (has_offset()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->offset());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Limit::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Limit* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Limit*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Limit::MergeFrom(const Limit& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_row_count()) {
      set_row_count(from.row_count());
    }
    if (from.has_offset()) {
      set_offset(from.offset());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Limit::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Limit::CopyFrom(const Limit& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Limit::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void Limit::Swap(Limit* other) {
  if (other != this) {
    std::swap(row_count_, other->row_count_);
    std::swap(offset_, other->offset_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Limit::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Limit_descriptor_;
  metadata.reflection = Limit_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* Order_Direction_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Order_Direction_descriptor_;
}
bool Order_Direction_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const Order_Direction Order::ASC;
const Order_Direction Order::DESC;
const Order_Direction Order::Direction_MIN;
const Order_Direction Order::Direction_MAX;
const int Order::Direction_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int Order::kExprFieldNumber;
const int Order::kDirectionFieldNumber;
#endif  // !_MSC_VER

Order::Order()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Mysqlx.Crud.Order)
}

void Order::InitAsDefaultInstance() {
  expr_ = const_cast< ::Mysqlx::Expr::Expr*>(&::Mysqlx::Expr::Expr::default_instance());
}

Order::Order(const Order& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:Mysqlx.Crud.Order)
}

void Order::SharedCtor() {
  _cached_size_ = 0;
  expr_ = NULL;
  direction_ = 1;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Order::~Order() {
  // @@protoc_insertion_point(destructor:Mysqlx.Crud.Order)
  SharedDtor();
}

void Order::SharedDtor() {
  if (this != default_instance_) {
    delete expr_;
  }
}

void Order::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Order::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Order_descriptor_;
}

const Order& Order::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mysqlx_5fcrud_2eproto();
  return *default_instance_;
}

Order* Order::default_instance_ = NULL;

Order* Order::New() const {
  return new Order;
}

void Order::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_expr()) {
      if (expr_ != NULL) expr_->::Mysqlx::Expr::Expr::Clear();
    }
    direction_ = 1;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Order::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Mysqlx.Crud.Order)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .Mysqlx.Expr.Expr expr = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_expr()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_direction;
        break;
      }

      // optional .Mysqlx.Crud.Order.Direction direction = 2 [default = ASC];
      case 2: {
        if (tag == 16) {
         parse_direction:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Mysqlx::Crud::Order_Direction_IsValid(value)) {
            set_direction(static_cast< ::Mysqlx::Crud::Order_Direction >(value));
          } else {
            mutable_unknown_fields()->AddVarint(2, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Mysqlx.Crud.Order)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Mysqlx.Crud.Order)
  return false;
#undef DO_
}

void Order::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Mysqlx.Crud.Order)
  // required .Mysqlx.Expr.Expr expr = 1;
  if (has_expr()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->expr(), output);
  }

  // optional .Mysqlx.Crud.Order.Direction direction = 2 [default = ASC];
  if (has_direction()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->direction(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Mysqlx.Crud.Order)
}

::google::protobuf::uint8* Order::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:Mysqlx.Crud.Order)
  // required .Mysqlx.Expr.Expr expr = 1;
  if (has_expr()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->expr(), target);
  }

  // optional .Mysqlx.Crud.Order.Direction direction = 2 [default = ASC];
  if (has_direction()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->direction(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Mysqlx.Crud.Order)
  return target;
}

int Order::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .Mysqlx.Expr.Expr expr = 1;
    if (has_expr()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->expr());
    }

    // optional .Mysqlx.Crud.Order.Direction direction = 2 [default = ASC];
    if (has_direction()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->direction());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Order::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Order* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Order*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Order::MergeFrom(const Order& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_expr()) {
      mutable_expr()->::Mysqlx::Expr::Expr::MergeFrom(from.expr());
    }
    if (from.has_direction()) {
      set_direction(from.direction());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Order::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Order::CopyFrom(const Order& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Order::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_expr()) {
    if (!this->expr().IsInitialized()) return false;
  }
  return true;
}

void Order::Swap(Order* other) {
  if (other != this) {
    std::swap(expr_, other->expr_);
    std::swap(direction_, other->direction_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Order::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Order_descriptor_;
  metadata.reflection = Order_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* UpdateOperation_UpdateType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return UpdateOperation_UpdateType_descriptor_;
}
bool UpdateOperation_UpdateType_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const UpdateOperation_UpdateType UpdateOperation::SET;
const UpdateOperation_UpdateType UpdateOperation::ITEM_REMOVE;
const UpdateOperation_UpdateType UpdateOperation::ITEM_SET;
const UpdateOperation_UpdateType UpdateOperation::ITEM_REPLACE;
const UpdateOperation_UpdateType UpdateOperation::ITEM_MERGE;
const UpdateOperation_UpdateType UpdateOperation::ARRAY_INSERT;
const UpdateOperation_UpdateType UpdateOperation::ARRAY_APPEND;
const UpdateOperation_UpdateType UpdateOperation::UpdateType_MIN;
const UpdateOperation_UpdateType UpdateOperation::UpdateType_MAX;
const int UpdateOperation::UpdateType_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int UpdateOperation::kSourceFieldNumber;
const int UpdateOperation::kOperationFieldNumber;
const int UpdateOperation::kValueFieldNumber;
#endif  // !_MSC_VER

UpdateOperation::UpdateOperation()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Mysqlx.Crud.UpdateOperation)
}

void UpdateOperation::InitAsDefaultInstance() {
  source_ = const_cast< ::Mysqlx::Expr::ColumnIdentifier*>(&::Mysqlx::Expr::ColumnIdentifier::default_instance());
  value_ = const_cast< ::Mysqlx::Expr::Expr*>(&::Mysqlx::Expr::Expr::default_instance());
}

UpdateOperation::UpdateOperation(const UpdateOperation& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:Mysqlx.Crud.UpdateOperation)
}

void UpdateOperation::SharedCtor() {
  _cached_size_ = 0;
  source_ = NULL;
  operation_ = 1;
  value_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UpdateOperation::~UpdateOperation() {
  // @@protoc_insertion_point(destructor:Mysqlx.Crud.UpdateOperation)
  SharedDtor();
}

void UpdateOperation::SharedDtor() {
  if (this != default_instance_) {
    delete source_;
    delete value_;
  }
}

void UpdateOperation::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* UpdateOperation::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return UpdateOperation_descriptor_;
}

const UpdateOperation& UpdateOperation::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mysqlx_5fcrud_2eproto();
  return *default_instance_;
}

UpdateOperation* UpdateOperation::default_instance_ = NULL;

UpdateOperation* UpdateOperation::New() const {
  return new UpdateOperation;
}

void UpdateOperation::Clear() {
  if (_has_bits_[0 / 32] & 7) {
    if (has_source()) {
      if (source_ != NULL) source_->::Mysqlx::Expr::ColumnIdentifier::Clear();
    }
    operation_ = 1;
    if (has_value()) {
      if (value_ != NULL) value_->::Mysqlx::Expr::Expr::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool UpdateOperation::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Mysqlx.Crud.UpdateOperation)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .Mysqlx.Expr.ColumnIdentifier source = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_source()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_operation;
        break;
      }

      // required .Mysqlx.Crud.UpdateOperation.UpdateType operation = 2;
      case 2: {
        if (tag == 16) {
         parse_operation:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Mysqlx::Crud::UpdateOperation_UpdateType_IsValid(value)) {
            set_operation(static_cast< ::Mysqlx::Crud::UpdateOperation_UpdateType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(2, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_value;
        break;
      }

      // optional .Mysqlx.Expr.Expr value = 3;
      case 3: {
        if (tag == 26) {
         parse_value:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_value()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Mysqlx.Crud.UpdateOperation)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Mysqlx.Crud.UpdateOperation)
  return false;
#undef DO_
}

void UpdateOperation::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Mysqlx.Crud.UpdateOperation)
  // required .Mysqlx.Expr.ColumnIdentifier source = 1;
  if (has_source()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->source(), output);
  }

  // required .Mysqlx.Crud.UpdateOperation.UpdateType operation = 2;
  if (has_operation()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->operation(), output);
  }

  // optional .Mysqlx.Expr.Expr value = 3;
  if (has_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->value(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Mysqlx.Crud.UpdateOperation)
}

::google::protobuf::uint8* UpdateOperation::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:Mysqlx.Crud.UpdateOperation)
  // required .Mysqlx.Expr.ColumnIdentifier source = 1;
  if (has_source()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->source(), target);
  }

  // required .Mysqlx.Crud.UpdateOperation.UpdateType operation = 2;
  if (has_operation()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->operation(), target);
  }

  // optional .Mysqlx.Expr.Expr value = 3;
  if (has_value()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->value(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Mysqlx.Crud.UpdateOperation)
  return target;
}

int UpdateOperation::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .Mysqlx.Expr.ColumnIdentifier source = 1;
    if (has_source()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->source());
    }

    // required .Mysqlx.Crud.UpdateOperation.UpdateType operation = 2;
    if (has_operation()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->operation());
    }

    // optional .Mysqlx.Expr.Expr value = 3;
    if (has_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->value());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UpdateOperation::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const UpdateOperation* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const UpdateOperation*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void UpdateOperation::MergeFrom(const UpdateOperation& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_source()) {
      mutable_source()->::Mysqlx::Expr::ColumnIdentifier::MergeFrom(from.source());
    }
    if (from.has_operation()) {
      set_operation(from.operation());
    }
    if (from.has_value()) {
      mutable_value()->::Mysqlx::Expr::Expr::MergeFrom(from.value());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void UpdateOperation::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UpdateOperation::CopyFrom(const UpdateOperation& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UpdateOperation::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (has_source()) {
    if (!this->source().IsInitialized()) return false;
  }
  if (has_value()) {
    if (!this->value().IsInitialized()) return false;
  }
  return true;
}

void UpdateOperation::Swap(UpdateOperation* other) {
  if (other != this) {
    std::swap(source_, other->source_);
    std::swap(operation_, other->operation_);
    std::swap(value_, other->value_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata UpdateOperation::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = UpdateOperation_descriptor_;
  metadata.reflection = UpdateOperation_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Find::kCollectionFieldNumber;
const int Find::kDataModelFieldNumber;
const int Find::kProjectionFieldNumber;
const int Find::kCriteriaFieldNumber;
const int Find::kArgsFieldNumber;
const int Find::kLimitFieldNumber;
const int Find::kOrderFieldNumber;
const int Find::kGroupingFieldNumber;
const int Find::kGroupingCriteriaFieldNumber;
#endif  // !_MSC_VER

Find::Find()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Mysqlx.Crud.Find)
}

void Find::InitAsDefaultInstance() {
  collection_ = const_cast< ::Mysqlx::Crud::Collection*>(&::Mysqlx::Crud::Collection::default_instance());
  criteria_ = const_cast< ::Mysqlx::Expr::Expr*>(&::Mysqlx::Expr::Expr::default_instance());
  limit_ = const_cast< ::Mysqlx::Crud::Limit*>(&::Mysqlx::Crud::Limit::default_instance());
  grouping_criteria_ = const_cast< ::Mysqlx::Expr::Expr*>(&::Mysqlx::Expr::Expr::default_instance());
}

Find::Find(const Find& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:Mysqlx.Crud.Find)
}

void Find::SharedCtor() {
  _cached_size_ = 0;
  collection_ = NULL;
  data_model_ = 1;
  criteria_ = NULL;
  limit_ = NULL;
  grouping_criteria_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Find::~Find() {
  // @@protoc_insertion_point(destructor:Mysqlx.Crud.Find)
  SharedDtor();
}

void Find::SharedDtor() {
  if (this != default_instance_) {
    delete collection_;
    delete criteria_;
    delete limit_;
    delete grouping_criteria_;
  }
}

void Find::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Find::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Find_descriptor_;
}

const Find& Find::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mysqlx_5fcrud_2eproto();
  return *default_instance_;
}

Find* Find::default_instance_ = NULL;

Find* Find::New() const {
  return new Find;
}

void Find::Clear() {
  if (_has_bits_[0 / 32] & 43) {
    if (has_collection()) {
      if (collection_ != NULL) collection_->::Mysqlx::Crud::Collection::Clear();
    }
    data_model_ = 1;
    if (has_criteria()) {
      if (criteria_ != NULL) criteria_->::Mysqlx::Expr::Expr::Clear();
    }
    if (has_limit()) {
      if (limit_ != NULL) limit_->::Mysqlx::Crud::Limit::Clear();
    }
  }
  if (has_grouping_criteria()) {
    if (grouping_criteria_ != NULL) grouping_criteria_->::Mysqlx::Expr::Expr::Clear();
  }
  projection_.Clear();
  args_.Clear();
  order_.Clear();
  grouping_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Find::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Mysqlx.Crud.Find)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .Mysqlx.Crud.Collection collection = 2;
      case 2: {
        if (tag == 18) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_collection()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_data_model;
        break;
      }

      // optional .Mysqlx.Crud.DataModel data_model = 3;
      case 3: {
        if (tag == 24) {
         parse_data_model:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Mysqlx::Crud::DataModel_IsValid(value)) {
            set_data_model(static_cast< ::Mysqlx::Crud::DataModel >(value));
          } else {
            mutable_unknown_fields()->AddVarint(3, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_projection;
        break;
      }

      // repeated .Mysqlx.Crud.Projection projection = 4;
      case 4: {
        if (tag == 34) {
         parse_projection:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_projection()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_projection;
        if (input->ExpectTag(42)) goto parse_criteria;
        break;
      }

      // optional .Mysqlx.Expr.Expr criteria = 5;
      case 5: {
        if (tag == 42) {
         parse_criteria:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_criteria()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_limit;
        break;
      }

      // optional .Mysqlx.Crud.Limit limit = 6;
      case 6: {
        if (tag == 50) {
         parse_limit:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_limit()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_order;
        break;
      }

      // repeated .Mysqlx.Crud.Order order = 7;
      case 7: {
        if (tag == 58) {
         parse_order:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_order()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_order;
        if (input->ExpectTag(66)) goto parse_grouping;
        break;
      }

      // repeated .Mysqlx.Expr.Expr grouping = 8;
      case 8: {
        if (tag == 66) {
         parse_grouping:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_grouping()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(66)) goto parse_grouping;
        if (input->ExpectTag(74)) goto parse_grouping_criteria;
        break;
      }

      // optional .Mysqlx.Expr.Expr grouping_criteria = 9;
      case 9: {
        if (tag == 74) {
         parse_grouping_criteria:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_grouping_criteria()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(90)) goto parse_args;
        break;
      }

      // repeated .Mysqlx.Datatypes.Scalar args = 11;
      case 11: {
        if (tag == 90) {
         parse_args:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_args()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(90)) goto parse_args;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Mysqlx.Crud.Find)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Mysqlx.Crud.Find)
  return false;
#undef DO_
}

void Find::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Mysqlx.Crud.Find)
  // required .Mysqlx.Crud.Collection collection = 2;
  if (has_collection()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->collection(), output);
  }

  // optional .Mysqlx.Crud.DataModel data_model = 3;
  if (has_data_model()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->data_model(), output);
  }

  // repeated .Mysqlx.Crud.Projection projection = 4;
  for (int i = 0; i < this->projection_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->projection(i), output);
  }

  // optional .Mysqlx.Expr.Expr criteria = 5;
  if (has_criteria()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->criteria(), output);
  }

  // optional .Mysqlx.Crud.Limit limit = 6;
  if (has_limit()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, this->limit(), output);
  }

  // repeated .Mysqlx.Crud.Order order = 7;
  for (int i = 0; i < this->order_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, this->order(i), output);
  }

  // repeated .Mysqlx.Expr.Expr grouping = 8;
  for (int i = 0; i < this->grouping_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      8, this->grouping(i), output);
  }

  // optional .Mysqlx.Expr.Expr grouping_criteria = 9;
  if (has_grouping_criteria()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      9, this->grouping_criteria(), output);
  }

  // repeated .Mysqlx.Datatypes.Scalar args = 11;
  for (int i = 0; i < this->args_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      11, this->args(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Mysqlx.Crud.Find)
}

::google::protobuf::uint8* Find::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:Mysqlx.Crud.Find)
  // required .Mysqlx.Crud.Collection collection = 2;
  if (has_collection()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->collection(), target);
  }

  // optional .Mysqlx.Crud.DataModel data_model = 3;
  if (has_data_model()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      3, this->data_model(), target);
  }

  // repeated .Mysqlx.Crud.Projection projection = 4;
  for (int i = 0; i < this->projection_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->projection(i), target);
  }

  // optional .Mysqlx.Expr.Expr criteria = 5;
  if (has_criteria()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->criteria(), target);
  }

  // optional .Mysqlx.Crud.Limit limit = 6;
  if (has_limit()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        6, this->limit(), target);
  }

  // repeated .Mysqlx.Crud.Order order = 7;
  for (int i = 0; i < this->order_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        7, this->order(i), target);
  }

  // repeated .Mysqlx.Expr.Expr grouping = 8;
  for (int i = 0; i < this->grouping_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        8, this->grouping(i), target);
  }

  // optional .Mysqlx.Expr.Expr grouping_criteria = 9;
  if (has_grouping_criteria()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        9, this->grouping_criteria(), target);
  }

  // repeated .Mysqlx.Datatypes.Scalar args = 11;
  for (int i = 0; i < this->args_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        11, this->args(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Mysqlx.Crud.Find)
  return target;
}

int Find::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .Mysqlx.Crud.Collection collection = 2;
    if (has_collection()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->collection());
    }

    // optional .Mysqlx.Crud.DataModel data_model = 3;
    if (has_data_model()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->data_model());
    }

    // optional .Mysqlx.Expr.Expr criteria = 5;
    if (has_criteria()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->criteria());
    }

    // optional .Mysqlx.Crud.Limit limit = 6;
    if (has_limit()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->limit());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional .Mysqlx.Expr.Expr grouping_criteria = 9;
    if (has_grouping_criteria()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->grouping_criteria());
    }

  }
  // repeated .Mysqlx.Crud.Projection projection = 4;
  total_size += 1 * this->projection_size();
  for (int i = 0; i < this->projection_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->projection(i));
  }

  // repeated .Mysqlx.Datatypes.Scalar args = 11;
  total_size += 1 * this->args_size();
  for (int i = 0; i < this->args_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->args(i));
  }

  // repeated .Mysqlx.Crud.Order order = 7;
  total_size += 1 * this->order_size();
  for (int i = 0; i < this->order_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->order(i));
  }

  // repeated .Mysqlx.Expr.Expr grouping = 8;
  total_size += 1 * this->grouping_size();
  for (int i = 0; i < this->grouping_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->grouping(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Find::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Find* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Find*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Find::MergeFrom(const Find& from) {
  GOOGLE_CHECK_NE(&from, this);
  projection_.MergeFrom(from.projection_);
  args_.MergeFrom(from.args_);
  order_.MergeFrom(from.order_);
  grouping_.MergeFrom(from.grouping_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_collection()) {
      mutable_collection()->::Mysqlx::Crud::Collection::MergeFrom(from.collection());
    }
    if (from.has_data_model()) {
      set_data_model(from.data_model());
    }
    if (from.has_criteria()) {
      mutable_criteria()->::Mysqlx::Expr::Expr::MergeFrom(from.criteria());
    }
    if (from.has_limit()) {
      mutable_limit()->::Mysqlx::Crud::Limit::MergeFrom(from.limit());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_grouping_criteria()) {
      mutable_grouping_criteria()->::Mysqlx::Expr::Expr::MergeFrom(from.grouping_criteria());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Find::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Find::CopyFrom(const Find& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Find::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_collection()) {
    if (!this->collection().IsInitialized()) return false;
  }
  if (!::google::protobuf::internal::AllAreInitialized(this->projection())) return false;
  if (has_criteria()) {
    if (!this->criteria().IsInitialized()) return false;
  }
  if (!::google::protobuf::internal::AllAreInitialized(this->args())) return false;
  if (has_limit()) {
    if (!this->limit().IsInitialized()) return false;
  }
  if (!::google::protobuf::internal::AllAreInitialized(this->order())) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->grouping())) return false;
  if (has_grouping_criteria()) {
    if (!this->grouping_criteria().IsInitialized()) return false;
  }
  return true;
}

void Find::Swap(Find* other) {
  if (other != this) {
    std::swap(collection_, other->collection_);
    std::swap(data_model_, other->data_model_);
    projection_.Swap(&other->projection_);
    std::swap(criteria_, other->criteria_);
    args_.Swap(&other->args_);
    std::swap(limit_, other->limit_);
    order_.Swap(&other->order_);
    grouping_.Swap(&other->grouping_);
    std::swap(grouping_criteria_, other->grouping_criteria_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Find::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Find_descriptor_;
  metadata.reflection = Find_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Insert_TypedRow::kFieldFieldNumber;
#endif  // !_MSC_VER

Insert_TypedRow::Insert_TypedRow()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Mysqlx.Crud.Insert.TypedRow)
}

void Insert_TypedRow::InitAsDefaultInstance() {
}

Insert_TypedRow::Insert_TypedRow(const Insert_TypedRow& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:Mysqlx.Crud.Insert.TypedRow)
}

void Insert_TypedRow::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Insert_TypedRow::~Insert_TypedRow() {
  // @@protoc_insertion_point(destructor:Mysqlx.Crud.Insert.TypedRow)
  SharedDtor();
}

void Insert_TypedRow::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Insert_TypedRow::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Insert_TypedRow::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Insert_TypedRow_descriptor_;
}

const Insert_TypedRow& Insert_TypedRow::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mysqlx_5fcrud_2eproto();
  return *default_instance_;
}

Insert_TypedRow* Insert_TypedRow::default_instance_ = NULL;

Insert_TypedRow* Insert_TypedRow::New() const {
  return new Insert_TypedRow;
}

void Insert_TypedRow::Clear() {
  field_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Insert_TypedRow::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Mysqlx.Crud.Insert.TypedRow)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .Mysqlx.Expr.Expr field = 1;
      case 1: {
        if (tag == 10) {
         parse_field:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_field()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_field;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Mysqlx.Crud.Insert.TypedRow)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Mysqlx.Crud.Insert.TypedRow)
  return false;
#undef DO_
}

void Insert_TypedRow::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Mysqlx.Crud.Insert.TypedRow)
  // repeated .Mysqlx.Expr.Expr field = 1;
  for (int i = 0; i < this->field_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->field(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Mysqlx.Crud.Insert.TypedRow)
}

::google::protobuf::uint8* Insert_TypedRow::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:Mysqlx.Crud.Insert.TypedRow)
  // repeated .Mysqlx.Expr.Expr field = 1;
  for (int i = 0; i < this->field_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->field(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Mysqlx.Crud.Insert.TypedRow)
  return target;
}

int Insert_TypedRow::ByteSize() const {
  int total_size = 0;

  // repeated .Mysqlx.Expr.Expr field = 1;
  total_size += 1 * this->field_size();
  for (int i = 0; i < this->field_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->field(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Insert_TypedRow::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Insert_TypedRow* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Insert_TypedRow*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Insert_TypedRow::MergeFrom(const Insert_TypedRow& from) {
  GOOGLE_CHECK_NE(&from, this);
  field_.MergeFrom(from.field_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Insert_TypedRow::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Insert_TypedRow::CopyFrom(const Insert_TypedRow& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Insert_TypedRow::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->field())) return false;
  return true;
}

void Insert_TypedRow::Swap(Insert_TypedRow* other) {
  if (other != this) {
    field_.Swap(&other->field_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Insert_TypedRow::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Insert_TypedRow_descriptor_;
  metadata.reflection = Insert_TypedRow_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Insert::kCollectionFieldNumber;
const int Insert::kDataModelFieldNumber;
const int Insert::kProjectionFieldNumber;
const int Insert::kRowFieldNumber;
const int Insert::kArgsFieldNumber;
#endif  // !_MSC_VER

Insert::Insert()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Mysqlx.Crud.Insert)
}

void Insert::InitAsDefaultInstance() {
  collection_ = const_cast< ::Mysqlx::Crud::Collection*>(&::Mysqlx::Crud::Collection::default_instance());
}

Insert::Insert(const Insert& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:Mysqlx.Crud.Insert)
}

void Insert::SharedCtor() {
  _cached_size_ = 0;
  collection_ = NULL;
  data_model_ = 1;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Insert::~Insert() {
  // @@protoc_insertion_point(destructor:Mysqlx.Crud.Insert)
  SharedDtor();
}

void Insert::SharedDtor() {
  if (this != default_instance_) {
    delete collection_;
  }
}

void Insert::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Insert::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Insert_descriptor_;
}

const Insert& Insert::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mysqlx_5fcrud_2eproto();
  return *default_instance_;
}

Insert* Insert::default_instance_ = NULL;

Insert* Insert::New() const {
  return new Insert;
}

void Insert::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_collection()) {
      if (collection_ != NULL) collection_->::Mysqlx::Crud::Collection::Clear();
    }
    data_model_ = 1;
  }
  projection_.Clear();
  row_.Clear();
  args_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Insert::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Mysqlx.Crud.Insert)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .Mysqlx.Crud.Collection collection = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_collection()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_data_model;
        break;
      }

      // optional .Mysqlx.Crud.DataModel data_model = 2;
      case 2: {
        if (tag == 16) {
         parse_data_model:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Mysqlx::Crud::DataModel_IsValid(value)) {
            set_data_model(static_cast< ::Mysqlx::Crud::DataModel >(value));
          } else {
            mutable_unknown_fields()->AddVarint(2, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_projection;
        break;
      }

      // repeated .Mysqlx.Crud.Column projection = 3;
      case 3: {
        if (tag == 26) {
         parse_projection:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_projection()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_projection;
        if (input->ExpectTag(34)) goto parse_row;
        break;
      }

      // repeated .Mysqlx.Crud.Insert.TypedRow row = 4;
      case 4: {
        if (tag == 34) {
         parse_row:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_row()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_row;
        if (input->ExpectTag(42)) goto parse_args;
        break;
      }

      // repeated .Mysqlx.Datatypes.Scalar args = 5;
      case 5: {
        if (tag == 42) {
         parse_args:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_args()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_args;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Mysqlx.Crud.Insert)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Mysqlx.Crud.Insert)
  return false;
#undef DO_
}

void Insert::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Mysqlx.Crud.Insert)
  // required .Mysqlx.Crud.Collection collection = 1;
  if (has_collection()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->collection(), output);
  }

  // optional .Mysqlx.Crud.DataModel data_model = 2;
  if (has_data_model()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->data_model(), output);
  }

  // repeated .Mysqlx.Crud.Column projection = 3;
  for (int i = 0; i < this->projection_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->projection(i), output);
  }

  // repeated .Mysqlx.Crud.Insert.TypedRow row = 4;
  for (int i = 0; i < this->row_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->row(i), output);
  }

  // repeated .Mysqlx.Datatypes.Scalar args = 5;
  for (int i = 0; i < this->args_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->args(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Mysqlx.Crud.Insert)
}

::google::protobuf::uint8* Insert::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:Mysqlx.Crud.Insert)
  // required .Mysqlx.Crud.Collection collection = 1;
  if (has_collection()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->collection(), target);
  }

  // optional .Mysqlx.Crud.DataModel data_model = 2;
  if (has_data_model()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->data_model(), target);
  }

  // repeated .Mysqlx.Crud.Column projection = 3;
  for (int i = 0; i < this->projection_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->projection(i), target);
  }

  // repeated .Mysqlx.Crud.Insert.TypedRow row = 4;
  for (int i = 0; i < this->row_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->row(i), target);
  }

  // repeated .Mysqlx.Datatypes.Scalar args = 5;
  for (int i = 0; i < this->args_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->args(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Mysqlx.Crud.Insert)
  return target;
}

int Insert::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .Mysqlx.Crud.Collection collection = 1;
    if (has_collection()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->collection());
    }

    // optional .Mysqlx.Crud.DataModel data_model = 2;
    if (has_data_model()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->data_model());
    }

  }
  // repeated .Mysqlx.Crud.Column projection = 3;
  total_size += 1 * this->projection_size();
  for (int i = 0; i < this->projection_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->projection(i));
  }

  // repeated .Mysqlx.Crud.Insert.TypedRow row = 4;
  total_size += 1 * this->row_size();
  for (int i = 0; i < this->row_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->row(i));
  }

  // repeated .Mysqlx.Datatypes.Scalar args = 5;
  total_size += 1 * this->args_size();
  for (int i = 0; i < this->args_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->args(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Insert::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Insert* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Insert*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Insert::MergeFrom(const Insert& from) {
  GOOGLE_CHECK_NE(&from, this);
  projection_.MergeFrom(from.projection_);
  row_.MergeFrom(from.row_);
  args_.MergeFrom(from.args_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_collection()) {
      mutable_collection()->::Mysqlx::Crud::Collection::MergeFrom(from.collection());
    }
    if (from.has_data_model()) {
      set_data_model(from.data_model());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Insert::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Insert::CopyFrom(const Insert& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Insert::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_collection()) {
    if (!this->collection().IsInitialized()) return false;
  }
  if (!::google::protobuf::internal::AllAreInitialized(this->projection())) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->row())) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->args())) return false;
  return true;
}

void Insert::Swap(Insert* other) {
  if (other != this) {
    std::swap(collection_, other->collection_);
    std::swap(data_model_, other->data_model_);
    projection_.Swap(&other->projection_);
    row_.Swap(&other->row_);
    args_.Swap(&other->args_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Insert::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Insert_descriptor_;
  metadata.reflection = Insert_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Update::kCollectionFieldNumber;
const int Update::kDataModelFieldNumber;
const int Update::kCriteriaFieldNumber;
const int Update::kArgsFieldNumber;
const int Update::kLimitFieldNumber;
const int Update::kOrderFieldNumber;
const int Update::kOperationFieldNumber;
#endif  // !_MSC_VER

Update::Update()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Mysqlx.Crud.Update)
}

void Update::InitAsDefaultInstance() {
  collection_ = const_cast< ::Mysqlx::Crud::Collection*>(&::Mysqlx::Crud::Collection::default_instance());
  criteria_ = const_cast< ::Mysqlx::Expr::Expr*>(&::Mysqlx::Expr::Expr::default_instance());
  limit_ = const_cast< ::Mysqlx::Crud::Limit*>(&::Mysqlx::Crud::Limit::default_instance());
}

Update::Update(const Update& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:Mysqlx.Crud.Update)
}

void Update::SharedCtor() {
  _cached_size_ = 0;
  collection_ = NULL;
  data_model_ = 1;
  criteria_ = NULL;
  limit_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Update::~Update() {
  // @@protoc_insertion_point(destructor:Mysqlx.Crud.Update)
  SharedDtor();
}

void Update::SharedDtor() {
  if (this != default_instance_) {
    delete collection_;
    delete criteria_;
    delete limit_;
  }
}

void Update::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Update::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Update_descriptor_;
}

const Update& Update::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mysqlx_5fcrud_2eproto();
  return *default_instance_;
}

Update* Update::default_instance_ = NULL;

Update* Update::New() const {
  return new Update;
}

void Update::Clear() {
  if (_has_bits_[0 / 32] & 23) {
    if (has_collection()) {
      if (collection_ != NULL) collection_->::Mysqlx::Crud::Collection::Clear();
    }
    data_model_ = 1;
    if (has_criteria()) {
      if (criteria_ != NULL) criteria_->::Mysqlx::Expr::Expr::Clear();
    }
    if (has_limit()) {
      if (limit_ != NULL) limit_->::Mysqlx::Crud::Limit::Clear();
    }
  }
  args_.Clear();
  order_.Clear();
  operation_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Update::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Mysqlx.Crud.Update)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .Mysqlx.Crud.Collection collection = 2;
      case 2: {
        if (tag == 18) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_collection()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_data_model;
        break;
      }

      // optional .Mysqlx.Crud.DataModel data_model = 3;
      case 3: {
        if (tag == 24) {
         parse_data_model:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Mysqlx::Crud::DataModel_IsValid(value)) {
            set_data_model(static_cast< ::Mysqlx::Crud::DataModel >(value));
          } else {
            mutable_unknown_fields()->AddVarint(3, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_criteria;
        break;
      }

      // optional .Mysqlx.Expr.Expr criteria = 4;
      case 4: {
        if (tag == 34) {
         parse_criteria:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_criteria()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_limit;
        break;
      }

      // optional .Mysqlx.Crud.Limit limit = 5;
      case 5: {
        if (tag == 42) {
         parse_limit:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_limit()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_order;
        break;
      }

      // repeated .Mysqlx.Crud.Order order = 6;
      case 6: {
        if (tag == 50) {
         parse_order:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_order()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_order;
        if (input->ExpectTag(58)) goto parse_operation;
        break;
      }

      // repeated .Mysqlx.Crud.UpdateOperation operation = 7;
      case 7: {
        if (tag == 58) {
         parse_operation:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_operation()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_operation;
        if (input->ExpectTag(66)) goto parse_args;
        break;
      }

      // repeated .Mysqlx.Datatypes.Scalar args = 8;
      case 8: {
        if (tag == 66) {
         parse_args:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_args()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(66)) goto parse_args;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Mysqlx.Crud.Update)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Mysqlx.Crud.Update)
  return false;
#undef DO_
}

void Update::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Mysqlx.Crud.Update)
  // required .Mysqlx.Crud.Collection collection = 2;
  if (has_collection()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->collection(), output);
  }

  // optional .Mysqlx.Crud.DataModel data_model = 3;
  if (has_data_model()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->data_model(), output);
  }

  // optional .Mysqlx.Expr.Expr criteria = 4;
  if (has_criteria()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->criteria(), output);
  }

  // optional .Mysqlx.Crud.Limit limit = 5;
  if (has_limit()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->limit(), output);
  }

  // repeated .Mysqlx.Crud.Order order = 6;
  for (int i = 0; i < this->order_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, this->order(i), output);
  }

  // repeated .Mysqlx.Crud.UpdateOperation operation = 7;
  for (int i = 0; i < this->operation_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, this->operation(i), output);
  }

  // repeated .Mysqlx.Datatypes.Scalar args = 8;
  for (int i = 0; i < this->args_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      8, this->args(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Mysqlx.Crud.Update)
}

::google::protobuf::uint8* Update::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:Mysqlx.Crud.Update)
  // required .Mysqlx.Crud.Collection collection = 2;
  if (has_collection()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->collection(), target);
  }

  // optional .Mysqlx.Crud.DataModel data_model = 3;
  if (has_data_model()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      3, this->data_model(), target);
  }

  // optional .Mysqlx.Expr.Expr criteria = 4;
  if (has_criteria()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->criteria(), target);
  }

  // optional .Mysqlx.Crud.Limit limit = 5;
  if (has_limit()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->limit(), target);
  }

  // repeated .Mysqlx.Crud.Order order = 6;
  for (int i = 0; i < this->order_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        6, this->order(i), target);
  }

  // repeated .Mysqlx.Crud.UpdateOperation operation = 7;
  for (int i = 0; i < this->operation_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        7, this->operation(i), target);
  }

  // repeated .Mysqlx.Datatypes.Scalar args = 8;
  for (int i = 0; i < this->args_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        8, this->args(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Mysqlx.Crud.Update)
  return target;
}

int Update::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .Mysqlx.Crud.Collection collection = 2;
    if (has_collection()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->collection());
    }

    // optional .Mysqlx.Crud.DataModel data_model = 3;
    if (has_data_model()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->data_model());
    }

    // optional .Mysqlx.Expr.Expr criteria = 4;
    if (has_criteria()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->criteria());
    }

    // optional .Mysqlx.Crud.Limit limit = 5;
    if (has_limit()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->limit());
    }

  }
  // repeated .Mysqlx.Datatypes.Scalar args = 8;
  total_size += 1 * this->args_size();
  for (int i = 0; i < this->args_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->args(i));
  }

  // repeated .Mysqlx.Crud.Order order = 6;
  total_size += 1 * this->order_size();
  for (int i = 0; i < this->order_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->order(i));
  }

  // repeated .Mysqlx.Crud.UpdateOperation operation = 7;
  total_size += 1 * this->operation_size();
  for (int i = 0; i < this->operation_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->operation(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Update::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Update* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Update*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Update::MergeFrom(const Update& from) {
  GOOGLE_CHECK_NE(&from, this);
  args_.MergeFrom(from.args_);
  order_.MergeFrom(from.order_);
  operation_.MergeFrom(from.operation_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_collection()) {
      mutable_collection()->::Mysqlx::Crud::Collection::MergeFrom(from.collection());
    }
    if (from.has_data_model()) {
      set_data_model(from.data_model());
    }
    if (from.has_criteria()) {
      mutable_criteria()->::Mysqlx::Expr::Expr::MergeFrom(from.criteria());
    }
    if (from.has_limit()) {
      mutable_limit()->::Mysqlx::Crud::Limit::MergeFrom(from.limit());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Update::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Update::CopyFrom(const Update& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Update::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_collection()) {
    if (!this->collection().IsInitialized()) return false;
  }
  if (has_criteria()) {
    if (!this->criteria().IsInitialized()) return false;
  }
  if (!::google::protobuf::internal::AllAreInitialized(this->args())) return false;
  if (has_limit()) {
    if (!this->limit().IsInitialized()) return false;
  }
  if (!::google::protobuf::internal::AllAreInitialized(this->order())) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->operation())) return false;
  return true;
}

void Update::Swap(Update* other) {
  if (other != this) {
    std::swap(collection_, other->collection_);
    std::swap(data_model_, other->data_model_);
    std::swap(criteria_, other->criteria_);
    args_.Swap(&other->args_);
    std::swap(limit_, other->limit_);
    order_.Swap(&other->order_);
    operation_.Swap(&other->operation_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Update::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Update_descriptor_;
  metadata.reflection = Update_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Delete::kCollectionFieldNumber;
const int Delete::kDataModelFieldNumber;
const int Delete::kCriteriaFieldNumber;
const int Delete::kArgsFieldNumber;
const int Delete::kLimitFieldNumber;
const int Delete::kOrderFieldNumber;
#endif  // !_MSC_VER

Delete::Delete()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Mysqlx.Crud.Delete)
}

void Delete::InitAsDefaultInstance() {
  collection_ = const_cast< ::Mysqlx::Crud::Collection*>(&::Mysqlx::Crud::Collection::default_instance());
  criteria_ = const_cast< ::Mysqlx::Expr::Expr*>(&::Mysqlx::Expr::Expr::default_instance());
  limit_ = const_cast< ::Mysqlx::Crud::Limit*>(&::Mysqlx::Crud::Limit::default_instance());
}

Delete::Delete(const Delete& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:Mysqlx.Crud.Delete)
}

void Delete::SharedCtor() {
  _cached_size_ = 0;
  collection_ = NULL;
  data_model_ = 1;
  criteria_ = NULL;
  limit_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Delete::~Delete() {
  // @@protoc_insertion_point(destructor:Mysqlx.Crud.Delete)
  SharedDtor();
}

void Delete::SharedDtor() {
  if (this != default_instance_) {
    delete collection_;
    delete criteria_;
    delete limit_;
  }
}

void Delete::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Delete::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Delete_descriptor_;
}

const Delete& Delete::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mysqlx_5fcrud_2eproto();
  return *default_instance_;
}

Delete* Delete::default_instance_ = NULL;

Delete* Delete::New() const {
  return new Delete;
}

void Delete::Clear() {
  if (_has_bits_[0 / 32] & 23) {
    if (has_collection()) {
      if (collection_ != NULL) collection_->::Mysqlx::Crud::Collection::Clear();
    }
    data_model_ = 1;
    if (has_criteria()) {
      if (criteria_ != NULL) criteria_->::Mysqlx::Expr::Expr::Clear();
    }
    if (has_limit()) {
      if (limit_ != NULL) limit_->::Mysqlx::Crud::Limit::Clear();
    }
  }
  args_.Clear();
  order_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Delete::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Mysqlx.Crud.Delete)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .Mysqlx.Crud.Collection collection = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_collection()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_data_model;
        break;
      }

      // optional .Mysqlx.Crud.DataModel data_model = 2;
      case 2: {
        if (tag == 16) {
         parse_data_model:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Mysqlx::Crud::DataModel_IsValid(value)) {
            set_data_model(static_cast< ::Mysqlx::Crud::DataModel >(value));
          } else {
            mutable_unknown_fields()->AddVarint(2, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_criteria;
        break;
      }

      // optional .Mysqlx.Expr.Expr criteria = 3;
      case 3: {
        if (tag == 26) {
         parse_criteria:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_criteria()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_limit;
        break;
      }

      // optional .Mysqlx.Crud.Limit limit = 4;
      case 4: {
        if (tag == 34) {
         parse_limit:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_limit()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_order;
        break;
      }

      // repeated .Mysqlx.Crud.Order order = 5;
      case 5: {
        if (tag == 42) {
         parse_order:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_order()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_order;
        if (input->ExpectTag(50)) goto parse_args;
        break;
      }

      // repeated .Mysqlx.Datatypes.Scalar args = 6;
      case 6: {
        if (tag == 50) {
         parse_args:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_args()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_args;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Mysqlx.Crud.Delete)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Mysqlx.Crud.Delete)
  return false;
#undef DO_
}

void Delete::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Mysqlx.Crud.Delete)
  // required .Mysqlx.Crud.Collection collection = 1;
  if (has_collection()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->collection(), output);
  }

  // optional .Mysqlx.Crud.DataModel data_model = 2;
  if (has_data_model()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->data_model(), output);
  }

  // optional .Mysqlx.Expr.Expr criteria = 3;
  if (has_criteria()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->criteria(), output);
  }

  // optional .Mysqlx.Crud.Limit limit = 4;
  if (has_limit()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->limit(), output);
  }

  // repeated .Mysqlx.Crud.Order order = 5;
  for (int i = 0; i < this->order_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->order(i), output);
  }

  // repeated .Mysqlx.Datatypes.Scalar args = 6;
  for (int i = 0; i < this->args_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, this->args(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Mysqlx.Crud.Delete)
}

::google::protobuf::uint8* Delete::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:Mysqlx.Crud.Delete)
  // required .Mysqlx.Crud.Collection collection = 1;
  if (has_collection()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->collection(), target);
  }

  // optional .Mysqlx.Crud.DataModel data_model = 2;
  if (has_data_model()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->data_model(), target);
  }

  // optional .Mysqlx.Expr.Expr criteria = 3;
  if (has_criteria()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->criteria(), target);
  }

  // optional .Mysqlx.Crud.Limit limit = 4;
  if (has_limit()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->limit(), target);
  }

  // repeated .Mysqlx.Crud.Order order = 5;
  for (int i = 0; i < this->order_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->order(i), target);
  }

  // repeated .Mysqlx.Datatypes.Scalar args = 6;
  for (int i = 0; i < this->args_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        6, this->args(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Mysqlx.Crud.Delete)
  return target;
}

int Delete::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .Mysqlx.Crud.Collection collection = 1;
    if (has_collection()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->collection());
    }

    // optional .Mysqlx.Crud.DataModel data_model = 2;
    if (has_data_model()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->data_model());
    }

    // optional .Mysqlx.Expr.Expr criteria = 3;
    if (has_criteria()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->criteria());
    }

    // optional .Mysqlx.Crud.Limit limit = 4;
    if (has_limit()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->limit());
    }

  }
  // repeated .Mysqlx.Datatypes.Scalar args = 6;
  total_size += 1 * this->args_size();
  for (int i = 0; i < this->args_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->args(i));
  }

  // repeated .Mysqlx.Crud.Order order = 5;
  total_size += 1 * this->order_size();
  for (int i = 0; i < this->order_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->order(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Delete::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Delete* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Delete*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Delete::MergeFrom(const Delete& from) {
  GOOGLE_CHECK_NE(&from, this);
  args_.MergeFrom(from.args_);
  order_.MergeFrom(from.order_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_collection()) {
      mutable_collection()->::Mysqlx::Crud::Collection::MergeFrom(from.collection());
    }
    if (from.has_data_model()) {
      set_data_model(from.data_model());
    }
    if (from.has_criteria()) {
      mutable_criteria()->::Mysqlx::Expr::Expr::MergeFrom(from.criteria());
    }
    if (from.has_limit()) {
      mutable_limit()->::Mysqlx::Crud::Limit::MergeFrom(from.limit());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Delete::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Delete::CopyFrom(const Delete& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Delete::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_collection()) {
    if (!this->collection().IsInitialized()) return false;
  }
  if (has_criteria()) {
    if (!this->criteria().IsInitialized()) return false;
  }
  if (!::google::protobuf::internal::AllAreInitialized(this->args())) return false;
  if (has_limit()) {
    if (!this->limit().IsInitialized()) return false;
  }
  if (!::google::protobuf::internal::AllAreInitialized(this->order())) return false;
  return true;
}

void Delete::Swap(Delete* other) {
  if (other != this) {
    std::swap(collection_, other->collection_);
    std::swap(data_model_, other->data_model_);
    std::swap(criteria_, other->criteria_);
    args_.Swap(&other->args_);
    std::swap(limit_, other->limit_);
    order_.Swap(&other->order_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Delete::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Delete_descriptor_;
  metadata.reflection = Delete_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace Crud
}  // namespace Mysqlx

// @@protoc_insertion_point(global_scope)
